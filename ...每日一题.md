牛客网版目录
* [注意事项](#注意事项)
* [编程题窍门](#编程题窍门)
* [二维数组中的查找](#面试题04_二维数组中的查找)
* [替换空格](#面试题05_替换空格)
* [从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [重建二叉树](#面试题07_重建二叉树)
* [用两个栈实现队列](#面试题09_用两个栈实现队列)
* [甜点](#第一星期甜点)
    * [length属性与length()函数](#length属性与length函数)
* [旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [斐波那契数列](#面试题10_斐波那契数列)
    * [青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [变态跳台阶](#本题扩展变态跳台阶)
    * [矩形覆盖](#相关题目矩形覆盖)
* [二进制中1的个数](#面试题15_二进制中1的个数)
* [数值的整数次方](#面试题16_数值的整数次方)
* [调整数组顺序使奇数位于偶数前面](#面试题21_调整数组顺序使奇数位于偶数前面)
* [链表中倒数第k个节点](#面试题22_链表中倒数第k个节点)
* [反转链表](#面试题24_反转链表)
* [合并两个排序的链表](#面试题25_合并两个排序的链表)
* [树的子结构](#面试题26_树的子结构)
* [二叉树的镜像](#面试题27_二叉树的镜像)
* [顺时针打印矩阵](#面试题29_顺时针打印矩阵)
* [包含min函数的栈](#面试题30_包含min函数的栈)
* [栈的压入_弹出序列](#面试题31_栈的压入_弹出序列)
* [从上到下打印二叉树](#面试题32_从上到下打印二叉树)
* [二叉搜索树的后序遍历序列](#面试题33_二叉搜索树的后序遍历序列)
* [二叉树中和为某一值的路径](#面试题34_二叉树中和为某一值的路径)
* [复杂链表的复制](#面试题35_复杂链表的复制)
* [二叉搜索树与双向链表](#面试题36_二叉搜索树与双向链表)
* [字符串的排列](#面试题38_字符串的排列)
* [数组中出现次数超过一半的数字](#面试题39_数组中出现次数超过一半的数字)
* [最小的k个数](#面试题40_最小的k个数)
* [连续子数组的最大和](#面试题42_连续子数组的最大和)



剑指Offer版目录
* [注意事项](#注意事项)
* [编程题窍门](#编程题窍门)
* [面试题04_二维数组中的查找](#面试题04_二维数组中的查找)
* [面试题05_替换空格](#面试题05_替换空格)
* [面试题06_从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [面试题07_重建二叉树](#面试题07_重建二叉树)
* [面试题09_用两个栈实现队列](#面试题09_用两个栈实现队列)
* [面试题10_斐波那契数列](#面试题10_斐波那契数列)
    * [题目二青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [本题扩展变态跳台阶](#本题扩展变态跳台阶)
    * [相关题目矩形覆盖](#相关题目矩形覆盖)
* [面试题11_旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [面试题15_二进制中1的个数](#面试题15_二进制中1的个数)
* [面试题16_数值的整数次方](#面试题16_数值的整数次方)
* [面试题21_调整数组顺序使奇数位于偶数前面](#面试题21_调整数组顺序使奇数位于偶数前面)
* [面试题22_链表中倒数第k个节点](#面试题22_链表中倒数第k个节点)
* [面试题23_反转链表](#面试题24_反转链表)
* [面试题25_合并两个排序的链表](#面试题25_合并两个排序的链表)
* [面试题26_树的子结构](#面试题26_树的子结构)
* [面试题27_二叉树的镜像](#面试题27_二叉树的镜像)
* [面试题29_顺时针打印矩阵](#面试题29_顺时针打印矩阵)
* [面试题30_包含min函数的栈](#面试题30_包含min函数的栈)
* [面试题31_栈的压入_弹出序列](#面试题31_栈的压入_弹出序列)
* [面试题32_从上到下打印二叉树](#面试题32_从上到下打印二叉树)
* [面试题33_二叉搜索树的后序遍历序列](#面试题33_二叉搜索树的后序遍历序列)
* [面试题34_二叉树中和为某一值的路径](#面试题34_二叉树中和为某一值的路径)
* [面试题35_复杂链表的复制](#面试题35_复杂链表的复制)
* [面试题36_二叉搜索树与双向链表](#面试题36_二叉搜索树与双向链表)
* [面试题38_字符串的排列](#面试题38_字符串的排列)
* [面试题39_数组中出现次数超过一半的数字](#面试题39_数组中出现次数超过一半的数字)
* [面试题40_最小的k个数](#面试题40_最小的k个数)
* [面试题42_连续子数组的最大和](#面试题42_连续子数组的最大和)
* [面试题56_数组中数字出现的次数](#面试题56_数组中数字出现的次数)

僻邪剑谱:
    * [堆排序](#堆排序)


# 注意事项

1.如无特别说明，方法均写在了Sword类中，测试代码均写在了Test类中，有很多方法直接在牛客网上书写并没有对应的测试代码

2.每道题的总结或解析部分给出了这道题应该注意的点，或者说这道题考察的点

# 编程题窍门

1.在程序的开头单独书写特殊输入的处理代码。

如当输入为数组的时候，数组为空怎么办，当输入为链表的时候，链表为空怎么办，当某个方法为求某个底数的指数次方，而输入的底数和指数都为0时怎么办。即使下面的程序段包含了特殊输入的处理代码也要单独写出来，一个是在面试中明确地告诉面试官，我们考虑了特殊输入的情况，我们有注意代码鲁棒性的意识，另一个是在工作中也使得代码更加清晰，可读性更强

2.在编写链表等相关代码的时候，不要从"开头"考虑如何编写代码，而是要从"中间"考虑如何编写代码。

如当你以这种想法考虑面试题25合并两个排序的链表的时候，你就要想，你已经有了合并好的链表的头节点head，还有没合并的排序链表头节点list1和list2，那么接下来你该如何编写代码呢？从这个角度出发，编写完循环内的代码，再处理一下开头就会容易的多

3.以前从来没有注意过这个常见的问题，就是当方法的参数为数组的时候(或其它类似情况)，也要考虑到int[] arr=null与int[] arr={}这两种特殊情况，相应的判断条件为if(arr==null || arr.length==0)

4.千万不要一开始就"死抠"简单的算法，使用最笨的算法快速实现也很重要，这在面试时，至少向面试官表明你的思维很敏捷

5.使用堆栈数据结构与函数递归解决问题同出一脉，一旦一个问题使用堆栈解决一定要意识到使用函数递归是否也可以解决该问题(反之亦然)，面试题34是一个典型的例子

# 面试题04_二维数组中的查找
题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

```java
    public boolean find(int target, int [][] array) {
        int r = array.length-1;
        int c = 0;
        while(r>-1 && c<array[0].length){
            if(target==array[r][c])
                return true;
            else if(target>array[r][c])
                c++;
            else
                r--;
        }
        return false;
    }
```

# 面试题05_替换空格

题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy

解析：

1.我们肯定要用到空格判断，那么怎么从字符串里边读取每个字符呢？查找API以下是我们可能会用到的方法

    StringBuffer(int capacity)
          构造一个不带字符，但具有指定初始容量的字符串缓冲区
    char charAt(int index)
          返回此序列中指定索引处的 char 值
    int length()
          返回长度（字符数）
    void setCharAt(int index, char ch)
          将给定索引处的字符设置为 ch
    void setLength(int newLength)
          设置字符序列的长度
    String toString()
          返回此序列中数据的字符串表示形式

其中的setLength方法：

```java
setLength
public void setLength(int newLength)设置字符序列的长度。序列将被更改为一个新的字符序列，新序列的长度由参数指定。对于每个小于 newLength 参数的非负索引 k，如果 k 小于原字符序列的长度，则新字符序列索引 k 处的字符与原字符序列索引 k 处的字符相同；否则，新字符序列索引 k 处的字符将是 null 字符 '\u0000'。换句话说，如果 newLength 参数小于当前长度，则长度将更改为指定的长度。
如果 newLength 参数大于或等于当前长度，则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数。

newLength 参数必须大于或等于 0。


参数：
newLength - 新长度
抛出：
IndexOutOfBoundsException - 如果 newLength 参数为负。
另请参见：
length()
```

2.还需明确一点就是容量和长度是两个不同的概念

```java
length
public int length()返回长度（字符数）。

指定者：
接口 CharSequence 中的 length
返回：
此对象表示的当前字符序列的长度。

--------------------------------------------------------------------------------

capacity
public int capacity()返回当前容量。容量指可用于最新插入的字符的存储量，超过这一容量就需要再次进行分配。 

返回：
当前容量。
```

所以有

```java
        StringBuffer str = new StringBuffer(13);
        System.out.println(str.length());
        System.out.println(str.capacity());

/*
$ java Test
0
13
*/
```

明确了这个知识点之后就知道如下程序是错误的了

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        StringBuffer newStr = new StringBuffer(newStrLength);
        int index = newStr.length()-1;//这里的newStr.length()为0而不是newStrLength
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                newStr.setCharAt(index--,'0');
                newStr.setCharAt(index--,'2');
                newStr.setCharAt(index--,'%');
            }
            else
                newStr.setCharAt(index--,str.charAt(i));
        }
        return newStr.toString();
    }
```


3.思路：我们可以先遍历一遍数组，查看有多少空格，再将字符序列长度设置为替换空格之后的长度，从后向前求解新的字符串

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        str.setLength(newStrLength);
        int index = newStrLength-1;
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                str.setCharAt(index--,'0');
                str.setCharAt(index--,'2');
                str.setCharAt(index--,'%');
            }
            else
                str.setCharAt(index--,str.charAt(i));
        }
        return str.toString();
    }
```

# 面试题06_从尾到头打印链表

题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList

### 自己的方法

自己的思路：

1.先遍历一遍链表，查看链表中元素的个数listNodeLength

2.再新建一个ArrayList对象，使其长度为listNodeLength

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面

问题：

可以新建一个ArrayList对象，使其容量为listNodeLength但是却不能使其元素数为listNodeLength，如下：

```java
ArrayList<Integer> al = new ArrayList<Integer>(13);
al.add(1,12);
/*
$ java Test
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 1, Size: 0
        at java.util.ArrayList.rangeCheckForAdd(Unknown Source)
        at java.util.ArrayList.add(Unknown Source)
        at Test.main(Test.java:16)
*/
```

如上虽然容量为13，但是Size依然为0，并没有1的索引，所以改进思路为：

1.新建立一个ArrayList对象

2.遍历一遍链表，将链表上的值依次存储在ArrayList对象里边

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面(改变原ArrayList的值)

```java
public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        ListNode head = listNode;
        while(listNode!=null){
            al.add(listNode.val);
            listNode = listNode.next;
        }
        for(int i=al.size()-1;i>-1;i--){
            al.set(i, head.val);
            head = head.next;
        }
        return al;
    }
```

### 答案1_利用栈

解析：

1.从头到尾遍历一遍链表，先遍历到的后输出，后遍历到的先输出，这是明显的先进后出规则，我们可以使用栈结构来实现

相关API

    boolean empty()
          测试堆栈是否为空
    E pop()
          移除堆栈顶部的对象，并作为此函数的值返回该对象
    E push(E item)
          把项压入堆栈顶部

```java
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        Stack<Integer> s = new Stack<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        while(listNode!=null){
            s.push(listNode.val);
            listNode = listNode.next;
        }
        while(!s.empty()){
            al.add(s.pop());
        }
        return al;
    }
```

### 答案2_利用递归

我们始终要记住一点：递归的本质就是一种栈结构，所以上述方式完全可以用递归方法改写

```java
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode!=null){
            //每次压栈时，里边都存有下一次压栈后printListFromTailToHead返回的ArrayList的引用变量al，在al里边add这一次压栈的节点的val值，返回al
            ArrayList<Integer> al = printListFromTailToHead(listNode.next);
            al.add(listNode.val);
            return al;
        }
        return new ArrayList();
    }
}
```

# 面试题07_重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

```java
public static TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0)
            return null;
        TreeNode root = new TreeNode(pre[0]);
        int rootIndex = 0;
        while(pre[0]!=in[rootIndex]){
            rootIndex++;
        }
        int[] leftIn = Arrays.copyOfRange(in, 0, rootIndex);
        int[] rightIn = Arrays.copyOfRange(in, rootIndex+1, in.length);
        int[] leftPre = Arrays.copyOfRange(pre, 1, rootIndex+1);
        int[] rightPre = Arrays.copyOfRange(pre, rootIndex+1, pre.length);
        root.left = reConstructBinaryTree(leftPre , leftIn);
        root.right = reConstructBinaryTree(rightPre ,rightIn);
        return root;
    }
```

# 面试题09_用两个栈实现队列

```java
import java.util.Stack;

class Queue{
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public void push(int node) {
         while(!stack2.empty()){
            stack1.push(stack2.pop());
        }
        stack1.push(node);

    }
    public int pop() {
        while(!stack1.empty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```

# 第一星期甜点

# length属性与length函数

1.length为属性，求得数组长度；length()为函数，用于求字符串的长度；size()函数用于求泛型类的元素多少

2.为什么数组的长度为属性，而字符串的长度(或者说泛型类的元素个数)为函数？

这是因为数组的长度一旦确定并不可以改动，而字符串长度(或者说泛型类的元素个数)可以改动，示例如下：

```java
import java.util.ArrayList;
class LengthTest{
    public static void main(String[] args){
        int[] arr = new int[8];
        int arrLength = arr.length;
        System.out.println("arrLength: "+arrLength);

        String s = new String();
        s = " hello world ";
        System.out.println("sLength: "+s.length());
        s = s.trim();
        System.out.println("sLength: "+s.length());

        ArrayList<Integer> arrList = new ArrayList<Integer>();
        System.out.println("arrListLength: "+arrList.size());
        arrList.add(5);
        System.out.println("arrListLength: "+arrList.size());
    }
}
/*
$ java LengthTest
arrLength: 8
sLength: 13
sLength: 11
arrListLength: 0
arrListLength: 1
*/
```

# 面试题11_旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

NOTE：给出的所有元素都大于0，若数组大小为0，请返回0

总结：

1.O(n)的方法很容易想到，但是并不是最优的

2.要注意并利用到旋转数组被分为了两个排序数组的特征

3.要考虑到{1,0,1,1,1,1}这类若干元素相等的情况

4.要考虑到{0,1,2,3,4,5,6}这类，把一个数组最开始的**0**个元素搬到数组的末尾的特殊情况

很容易想到当出现一个数大于后面的数字，那么后面的那个数字就是最小的数，程序如下，但是这种方法的时间复杂度为O(n)

1.该方法没有用到太多的旋转数组的特性，只认识到了"当出现一个数大于后面的数字，那么后面的那个数字就是最小的数"，其实还应该认识到，**旋转数组旋转之后变为了两个排序数组**

```java
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        else{
            for(int i=0;i<array.length-1;){
                if(array[i]>array[++i])
                    return array[i];
            }
        }
        return -1;//当输入为非法数组(非符合要求的旋转数组)的时候的输出，这点可以和面试官确认一下，表示我们考虑到了这种情况
    }
```

又想到能否使用递归呢？

```java
    public int minNumberInRotateArray(int [] array) {
        int index = array.length/2;
        if(index==0)
            return -1;
        if(array[index-1]>array[index])
            return array[index];
        int left = minNumberInRotateArray(Arrays.copyOfRange(array, 0, index));
        int right = minNumberInRotateArray(Arrays.copyOfRange(array, index, array.length));
        if(left!=-1)
            return left;
        if(right!=-1)
            return right;
        return -1;
    }
```

牛客网中一java版高赞回答，是错误的，没有考虑到特殊情况，如{1,0,1,1,1,1}，但是该方法注意到了旋转数组为两个排序数组的特性(注意还有不旋转的排序数组也是旋转数组)，也没有考虑到{0,1,2,3,4,5,6,7,8,9}的情况

```java
public class Test11{
    public static void main(String[] args){
        int[] arr = {1,0,1,1,1,1,1};
        int min = minNumberInRotateArray(arr);
        System.out.println(min);
    }
    public static int minNumberInRotateArray(int[] array) {
        if (array.length == 0)
            return 0;
        int left = 0;
        int right = array.length - 1;
        int middle = -1;
        while (array[left]>=array[right]) {
            if(right-left==1){
                middle = right;
                break;
            }
            middle = left + (right - left) / 2;
            if (array[middle] >= array[left]) {
                left = middle;
            }
            if (array[middle] <= array[right]) {
                right = middle;
            }
        }
        return array[middle];
    }
}
```

上述程序会陷入死循环，将其修改后为：

```java
public class Test11_1{
    public static void main(String[] args){
        int[] arr0 = {1,0,1,1,1,1,1};
        int[] arr1 = {5,6,7,8,0,1,2,3,4};
        int[] arr2 = {0,1,2,3,4,5,6,7,8};
        int min = minNumberInRotateArray(arr1);
        System.out.println(min);
        System.exit(0);
    }
    public static int minNumberInRotateArray(int[] array) {
        if(array==null)
            throw new RuntimeException("数组不可以为空");
        int leftIndex = 0;
        int rightIndex = array.length-1;
        if(array[leftIndex]<array[rightIndex]){
            return array[leftIndex];
        }
        int midIndex;
        while((rightIndex-leftIndex)>1){
            midIndex = (leftIndex + rightIndex)/2;
            int temp;
            if(array[leftIndex] > array[midIndex])
                rightIndex = midIndex;
            else if(array[leftIndex] < array[midIndex])
                leftIndex = midIndex;
            else if((array[leftIndex] == array[midIndex]) || (array[rightIndex] == array[midIndex])){
                temp = leftIndex+1;
                if(array[leftIndex] == array[temp])
                    leftIndex++;
                temp = rightIndex-1;
                if(array[rightIndex] == array[temp])
                    rightIndex--;
            }
        }
        return array[rightIndex];
    }
}
```

# 面试题10_斐波那契数列

题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

总结：

1.递归方式很容易想到，但是会计算重复项，效率不高

2.从第一项计算到第n项可取

3.有更高阶的方式解决此题，比如通项公式等

递归的方式很容易想到

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}
```

但是递归的问题是，一个斐波那契数列项会被多次重复计算，比如计算f(10)=f(9)+f(8)，而计算f(9)的时候又会计算f(8)，导致计算的速度很慢，可以重第一项计算到第n项，就不会出现重复计算的情况

```java
    public static int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        int first = 0;
        int second = 1;
        int temp;
        for(int i=0;i<n;i++){
            first = first+second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
```
### 题目二青蛙跳台阶问题

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target<=0)
            throw new RuntimeException("target必须大于0");
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```

### 本题扩展变态跳台阶

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

解析：用归纳法不难证明答案为2的n次方，但是此题的知识点归类为贪婪算法，查看讨论中，并未发现应用贪婪算法的解法

```java
public class Solution {
    public int JumpFloorII(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于等于1");
        return 1<<(target-1);
    }
}
```

### 相关题目矩形覆盖

题目：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int RectCover(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于0");
        if(target==0)
            return 0;
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```

# 面试题15_二进制中1的个数

题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示

总结：

1.方法一：不断进行无符号右移操作，并且在位移的过程中与1进行位与运算(判断最后一位是否为1)……

2.方法二：利用n&(n-1)相当于把int型的数n的二进制的最后一位设置为0的trick

一个容易想到的思路为，该数与1相与得到最后一位数字，判断其是1还是0，不断右移，判断全部的32位数

```java
public class Solution {
    public int NumberOf1(int n) {
        int numbers = 0;
        while(n!=0){
            if((n&1)==1)
                numbers++;
            n=n>>>1;
        }
        return numbers;
    }
}
```

如果注意到当一个数与该数减去1之后的结果相与，那么就相当于把该数最右边的1置为0的trick之后，程序可以改为：

```java
    static int NumberOf1(int n) {
        int numbers = 0;
        while(n!=0){
            numbers++;
            n=n&(n-1);
        }
        return numbers;
    }
```

# 面试题16_数值的整数次方

题目：实现函数double Power(double base, int exponent)，求base得exponent次方。不得使用库函数，同时不需要考虑大数问题

解析：

1.base为0的时候，exponent不可以同时为0，这个时候程序的规定输出要和面试官说明(本程序此种情况输出为0)，表明我们考虑到了这种情况，其实博主觉得可以考虑在此种情况下输出异常

2.当base为0的时候，exponent不为0则输出为0

3.注意exponent的取值，取正值，取负值，取负值的结果等于其绝对值的power取倒数，取0，结果为1

4.考虑高效算法

![power](https://github.com/geekavan/Sword/blob/master/power.png)

5.可以通过位运算判断一个数的奇偶，(exponent & 1)==0

综上，我们有：

```java
public class Sword{
    static double power(double base, int exponent){
        if(base==0 && exponent==0)
            return 0;
        if(base==0)
            return 0;
        if(exponent<0)
            return 1/(power(base, -exponent));
        if(exponent==0)
            return 1;
        if(exponent%2==0){
            double temp = power(base, exponent/2);
            return temp*temp;
        }
        else
            return base*power(base, (exponent-1));
    }
}
class Test{
    public static void main(String[] args){
        double s16  = Sword.power(5, -2);
        System.out.println(s16);
    }
}
/*
$ java Test
0.04
*/
```

总结：

1.知道如何通过位运算判断一个数为奇数还是偶数

2.知道如何通过位运算将一个数乘以2或除以2

学完异常之后再做此题为

```java
public class Solution {
    public double Power(double base, int exponent) {
        if(base==0 && exponent==0)
            throw new RuntimeException("底数和指数不可以同时为0!");
        if(exponent==0)
            return 1.0;
        if(base==0)
            return 0.0;
        if(exponent<0)
            return 1/Power(base, -exponent);
        if((exponent&1)==0)
            return Power(base,exponent>>1)*Power(base,exponent>>1);
        return base*Power(base,exponent-1);
  }
}
```

# 面试题21_调整数组顺序使奇数位于偶数前面

题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

总结：

1.该题与剑指Offer相比做了改动，剑指Offer第2版中本题并不要求稳定性(相对位置不变)

2.(若不要求稳定性)维护两个指针就可以了，开头一个，结尾一个

3.(若不要求稳定性)该题使博主想起了替换空格的那道题，可以先遍历数组找出奇数和偶数的个数，再在奇数结束位置处维护偶数指针(其实多此一举，直接在开头和结尾维护指针就可以了)

4.(若要求稳定性)直接应用具有稳定性的经典排序算法思路就可以了，下文中演示了此方式(应用插入排序思路)

5.以剑指Offer说法，本题考查程序的可扩展性，那要是负数排前面，非负数排后面呢？要是被3整除的排前面，不被3整除的排后面呢？

解析：应用一个稳定的排序算法思路就可以了，首先想到了插入算法思想

```java
public class Solution {
    public void reOrderArray(int [] array) {
        for(int i=0;i<array.length;i++){
            for(int j = i;(j>0) && ((array[j]&1)==1) && ((array[j-1]&1)==0);j--){
                swap(array, j,j-1);
            }
        }
    }
    public static void swap(int[] arr, int i, int j){
        int temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

考虑到总结中的第5点，程序的可扩展性问题，将程序改为：

```java
public class Solution {
    public void reOrderArray(int [] array) {
        for(int i=0;i<array.length;i++){
            for(int j = i;(j>0) && function(array, j, j-1);j--){
                swap(array, j,j-1);
            }
        }
    }
    public static void swap(int[] arr, int i, int j){
        int temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static boolean function(int[] arr, int i, int j){
        if((arr[i]&1)==1)
            if((arr[j]&1)==0)
                return true;
        return false;
    }
}
```

这样如果改需求的话，可以直接改写function函数就好了

# 面试题22_链表中倒数第k个节点

题目：输入一个链表，输出该链表中倒数第k个结点

总结：

1.该题考查应试者编程的鲁棒性，别忘记了考虑特殊输入，head为null，k小于链表的节点数，k为负数，k为0

解析：

1.博主以前做过这道题，直接想到维护两个相距k的指针就好了

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        ListNode first = head;
        int i;
        for(i=0;(i<k) && (first!=null);i++)
            first = first.next;
        if(i!=k)
            return null;
        while(first!=null){
            head = head.next;
            first = first.next;
        }
        return head;
    }
}
```

上述解法通过了牛客网的检测，但显然是不合适的，当我输入k小于或等于0的时候，返回为空，当我输入k为负数的时候，返回也是空，这合适吗？当输入为负数，滥用这个方法的时候，直接抛出运行时异常！停掉调用者的程序

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null)//考虑到了空指针的情况，当然这一点下边的程序也涵盖了，但是单列出来比较好，一个是告诉面试者我考虑到了这种情况，另一个实际开发的时候也比较清晰，以后都这么写！
            return null;
        if(k<0)//考虑到了k小于0的情况，当然k是否可以等于0，约定俗成就好，这了为了通过牛客网测试没有包含0
            throw new RuntimeException("k必须大于等于0");
        ListNode first = head;
        int i;
        for(i=0;(i<k) && (first!=null);i++)
            first = first.next;
        if(i!=k)//考虑到了链表节点数小于k的情况，至于处理方式也可以选择抛出异常(这类问题都可以和面试官确认)，这里为了通过牛客网测试选择了返回空
            return null;
        while(first!=null){
            head = head.next;
            first = first.next;
        }
        return head;
    }
}
```

# 面试题24_反转链表

题目：输入一个链表，反转链表后，输出新链表的表头

总结：

1.有些问题不要从"头"想，要从"中间位置"想

2.该题考查代码的鲁棒性，可以将特殊输入的处理代码段单列在程序开头，比如博主这里将输入为null的情况的处理单列在程序开始的部分，虽然后续的程序段也可以圆满地解决这个特殊输入，但是单列出来，一个是在面试中告诉面试官，我考虑到了这种情况，另一个是在实际工作中使自己的代码更加清晰易读

解析：

1.从"中间位置"想的话，很容易得到while循环中的代码

2.该题考查代码的鲁棒性，要保证当输入为null，只有一个节点时，代码能够正常执行

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null)
            return null;
        ListNode node = head;
        ListNode first = null;
        while(node!=null){
            ListNode nodeNext = node.next;
            node.next = first;
            first = node;
            node = nodeNext;
        }
        return first;
    }
}
```

# 面试题25_合并两个排序的链表

题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则

解析：

1.考虑特殊输入

2.从"中间开始考虑"，不要从"开头考虑"

总结：

1.我们要注意函数的返回值是什么类型--->ListNode

2.我们要注意如果使用递归的话，递归的那个函数的功能是什么？--->找出头节点list1和list2中值较小的那一个并返回

3.我们要怎么才能保证返回的是单调不减链表？--->一个是返回两个头节点中较小的一个，另一个是该较小的头节点的下一个节点也是下两个排序链表头结点中较小的一个

4.一个递归函数对应一个栈帧，我们要保证该栈帧中返回的是**两个排序链表头结点中较小的一个节点**，该节点的下一个节点也是**下两个排序链表头节点中较小的一个节点**

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1==null)
            return list2;
        if(list2==null)
            return list1;
        ListNode head = new ListNode(0);
        ListNode first=null;
        for(int i=0;((list1!=null)&&(list2!=null));i++){
            if(list1.val<list2.val){
                head.next = list1;
                if(i==0)
                    first = head;
                head = head.next;
                list1 = list1.next;
            }
            else{
                head.next = list2;
                if(i==0)
                    first = head;
                head = head.next;
                list2 = list2.next;
            }
        }
        if(list1==null)
            head.next = list2;
        if(list2==null)
            head.next = list1;
        return first.next;
    }
}
```

剑指Offer的解答：

当我们得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1==null)
            return list2;
        if(list2==null)
            return list1;
        if(list1.val<list2.val){
            list1.next = Merge(list1.next, list2);
            return list1;
        }
        else{
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }
}
```

# 面试题26_树的子结构

题目：输入两棵二叉树A，B，判断B是不是A的子结构。(ps：我们约定空树不是任意一个树的子结构)

解析：

1.一个比较容易想到的思路(我的思路)就是设定一个函数，subTree(TreeNode root1, TreeNode root2)用于判断以root1为起始根节点的二叉树是否包含root2的子结构，再将HasSubtree中的root1进行遍历，每一个节点都调用subTree()函数

2.该题考查编写代码的鲁棒性，完整性，标准答案与博主思路类同

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.LinkedList;
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null)
            return false;
        if(root1==null)
            return false;
        LinkedList<TreeNode> queue1 = new LinkedList<TreeNode>();
        queue1.push(root1);
        while(!queue1.isEmpty()){
            TreeNode first = queue1.pop();
            if(subTree(first, root2))
                return true;
            if(first.left!=null)
                queue1.push(first.left);
            if(first.right!=null)
                queue1.push(first.right);
        }
        return false;
    }
    public boolean subTree(TreeNode root1, TreeNode root2){
        LinkedList<TreeNode> queue1 = new LinkedList<TreeNode>();
        LinkedList<TreeNode> queue2 = new LinkedList<TreeNode>();
        queue1.push(root1);
        queue2.push(root2);
        while(!queue2.isEmpty()){
            TreeNode first1 = queue1.pop();
            TreeNode first2 = queue2.pop();
            if(first1.val!=first2.val)
                return false;
            if(first2.left!=null){
                if(first1.left==null)
                    return false;
                queue2.push(first2.left);
                queue1.push(first1.left);
            }
            if(first2.right!=null){
                if(first1.right==null)
                    return false;
                queue2.push(first2.right);
                queue1.push(first1.right);
            }
        }
        return true;
    }
}
```

# 面试题27_二叉树的镜像

题目：操作给定的二叉树，将其变换为源二叉树的镜像

解析：

1.博主思路：借助队列的数据结构遍历二叉树，将每个节点的左右子树对换即可

2.本题考查面试者对于二叉树的理解，本质上在考查二叉树的遍历算法

3.博主的思路为借助队列进行层序遍历，那么如果使用其它的二叉树遍历方式，该如何编写？

借助队列进行按层遍历的解决方式：

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.LinkedList;
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        queue.push(root);
        while(!queue.isEmpty()){
            TreeNode first  = queue.pop();
            TreeNode temp = first.left;
            first.left = first.right;
            first.right = temp;
            if(first.left!=null)
                queue.push(first.left);
            if(first.right!=null)
                queue.push(first.right);
        }
    }
}
```

借助递归的解决方式

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return ;
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        if(root.left!=null)
            Mirror(root.left);
        if(root.right!=null)
            Mirror(root.right);
    }
}
```

# 面试题29_顺时针打印矩阵

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

总结：

1.有些情况下头尾索引都包含的话有利于编写代码，比如上述的这道题，如果只包含头索引而不包含尾索引的话，可能会麻烦一点，当然这一点并不是必须遵守的

2.四个for循环中循环条件很重要，很容易把&&后的条件漏掉而导致错误

3.该题考查面试者逻辑思维能力，若考虑的不周全，代码很容易在某些输入下出现错误

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        int rmin=0;
        int rmax=matrix.length-1;
        int cmin=0;
        int cmax=matrix[0].length-1;
        while(rmin<=rmax && cmin<=cmax){
           for(int j=cmin;j<=cmax && rmin<=rmax;j++)
               list.add(matrix[rmin][j]);
           rmin++;
           for(int i=rmin;i<=rmax && cmin<=cmax;i++)
               list.add(matrix[i][cmax]);
           cmax--;
           for(int j=cmax;j>=cmin && rmin<=rmax;j--)
               list.add(matrix[rmax][j]);
           rmax--;
            for(int i=rmax;i>=rmin && cmin<=cmax;i--)
                list.add(matrix[i][cmin]);
           cmin++;
        }
        return list;
    }
}
```

# 面试题30_包含min函数的栈

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

解析：

1.pretty easy

```java
import java.util.Stack;
public class Solution {
    Stack<Integer> s = new Stack<Integer>();
    Stack<Integer> smin = new Stack<Integer>();
    public void push(int node) {
        s.push(node);
        if(smin.isEmpty()){
            smin.push(node);
        }
        else{
            if(node<smin.peek())
                smin.push(node);
            else
                smin.push(smin.peek());
        }
    }
    public void pop() {
        s.pop();
        smin.pop();
    }
    
    public int top() {
        smin.pop();
        return s.pop();
    }
    public int min() {
        return smin.peek();
    }
}
```

# 面试题31_栈的压入_弹出序列

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。注意：这两个序列的长度是相等的

解析：

1.构造一个辅助栈来模拟栈的压入弹出即可，为了方便查找popA中的某个数字在不在pushA中(除去已经压入栈中的数字的pushA)，这里将pushA中的数字也存储在了ArrayList结构中

2.要注意当stackA中和stackTemp中都没有popA中的某一个数字，则返回false

3.该题考查应聘者分析复杂问题的能力，可以通过举一两个例子，一步步分析压栈和弹出的过程，总中找出规律

```java
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA==null && popA==null)
            return true;
        if(pushA==null || popA==null)
            return false;
        ArrayList<Integer> stackA = new ArrayList<Integer>();
        ArrayList<Integer> stackTemp = new ArrayList<Integer>();
        for(int i=0;i<pushA.length;i++)
            stackA.add(pushA[i]);
        for(int i=0;i<popA.length;i++){
            int index = stackA.indexOf(popA[i]);
            int indexTemp = stackTemp.indexOf(popA[i]);
            if(index!=-1){
                for(int j=0;j<=index;j++)
                    stackTemp.add(stackA.remove(0));
                stackTemp.remove(stackTemp.size()-1);
            }
            else if(index==-1 && indexTemp!=-1){
                if(stackTemp.remove(stackTemp.size()-1)!=popA[i])
                    return false;
            }
            else
                return false;
        }
        return true;
    }
}
```

讨论中的高赞回答：

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length == 0 || popA.length == 0)
            return false;
        Stack<Integer> s = new Stack<Integer>();
        //用于标识弹出序列的位置
        int popIndex = 0;
        for(int i = 0; i< pushA.length;i++){
            s.push(pushA[i]);
            //如果栈不为空，且栈顶元素等于弹出序列
            while(!s.empty() &&s.peek() == popA[popIndex]){
                //出栈
                s.pop();
                //弹出序列向后一位
                popIndex++;
            }
        }
        return s.empty();
    }
}
```

解析：

1.该回答仅用了一个辅助数据结构

2.该回答非常巧妙，pushA中的每一个数字都要压栈，那么就依次压入数字，每压入一个数字，都检查该数字是否是popA此时的弹出数字，如果不是则继续压栈，如果是的话，那么弹出辅助栈中的数字，并且检查下一个辅助栈中的数字是否是popA此时的弹出数字，如果不是则继续压栈，如果是的话......最后如果辅助栈中无数字剩余，那么结果为真，否则结果为假(其实这样的话，是不是如果输入的两个序列长度不相等的话就会出现bug，虽然题设中有规定两者相等，但是如果两者不相等会出现bug的话，最好还是进行防御性编程)

经检验

```java
        int[] pushA = {1,2,3,4,5,6,7,8};
        int[] popA = {1,2,3,6,8,7,5,4,9};
        System.out.println(Sword.IsPopOrder(pushA, popA));//true
```

所以说还是加上防御性的程序段

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length == 0 && popA.length == 0)//该段代码使特殊输入的处理更加清晰
            return true;
        if(pushA.length == 0 || popA.length == 0)
            return false;
        if(pushA.length!=popA.length)//加入了这段防御性代码片段，其实题设说了两者相等
            return false;
        Stack<Integer> s = new Stack<Integer>();
        //用于标识弹出序列的位置
        int popIndex = 0;
        for(int i = 0; i< pushA.length;i++){
            s.push(pushA[i]);
            //如果栈不为空，且栈顶元素等于弹出序列
            while(!s.empty() &&s.peek() == popA[popIndex]){
                //出栈
                s.pop();
                //弹出序列向后一位
                popIndex++;
            }
        }
        return s.empty();
    }
}
```

# 面试题32_从上到下打印二叉树

题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印

总结：

1.当root为空的时候，不应该返回null，那样的话会报错，因为方法的返回值类型为ArrayList<Integer>所以如果返回为null的话就相当于

```java
ArrayList<Integer> list = null;//java.lang.NullPointerException
```

应该返回为new ArrayList<Integer>();相当于(为什么上边有的程序返回为null就可以？)

```java
ArrayList<Integer> list = new ArrayList<Integer>();
```

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        if(root==null)
            return new ArrayList<Integer>();//注意返回不应该为null
        ArrayList<TreeNode> listNode = new ArrayList<TreeNode>();
        ArrayList<Integer> listInteger = new ArrayList<Integer>();
        listNode.add(root);
        while(!listNode.isEmpty()){
            TreeNode first = listNode.remove(0);
            listInteger.add(first.val);
            if(first.left!=null)
                listNode.add(first.left);
            if(first.right!=null)
                listNode.add(first.right);
        }
        return listInteger;
    }
}
```

# 面试题33_二叉搜索树的后序遍历序列

题目:输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同

解析:

1.举两个例子，找一下规律，也并不是很难

2.当方法的参数为数组时，要考虑到int[] arr=null与int[] arr={}这两种特殊的情况

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        return verify(sequence, 0, sequence.length-1);
    }
    public boolean verify(int[] arr, int begin, int end){
        if(arr==null || arr.length==0)
            return false;
        if(begin>=end)
            return true;
        int root = arr[end];
        int rootIndex;
        int i;
        for(i=end;(i>=begin) && (arr[i] >= root);i--){}
        rootIndex = i;
        for(;i>=begin;i--){
            if(arr[i] >= root)
                return false;
        }
        return verify(arr, begin, rootIndex)&&verify(arr, rootIndex+1, end-1);
    }
}
```

3.我们最好把一个方法的全部封装到一起，这样有利于方法的复用，例子如下(来源于牛客网本题的Java版高赞回答)

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0)
            return false;
        if(sequence.length==1)
            return true;
        return ju(sequence, 0, sequence.length-1);     
    }
    public boolean ju(int[] a,int star,int root){
        if(star>=root)
            return true;
        int i = root;
        //从后面开始找
        while(i>star&&a[i-1]>a[root])
            i--;//找到比根小的坐标
        //从前面开始找 star到i-1应该比根小
        for(int j = star;j<i-1;j++)
            if(a[j]>a[root])
                return false;;
        return ju(a,star,i-1)&&ju(a, i, root-1);
    }
}
```

我们看到，ju这个方法是查看a数组中索引从start到root的数组是否为后序遍历序列，该功能为一个独立的整体，封装为了一个独立的方法，但是该独立的方法的内部确是不完整的，缺乏对输入数组a的检查，这是不好的，虽然完成了要求的功能，但是却有损于ju方法的复用(还有这个函数名也太不清晰了)

4.该问题可以使用非递归方式改写，思路为:序列的最后一个数字总是为某一个子树的根节点，它前面的序列总会被这个数字分为小于它和大于它的左右两个序列，那么我们可以在最外层设置一个循环，用于循环最后一个数字，从后到前，在每一次的循环中，我们检查是否最后一个数字将其前面的序列分为小于和大于它的左右两个部分，这一步可以选择的方式为:如果序列被分为小于和大于它的两个部分，那么我们设置一个初始为0的索引指针，如果索引位置处的数字小于这次循环中的最后一个数字，那么指针加1，不断重复这一个过程，指针将指完小于这次循环的最后一个数字，紧接着如果索引位置处的数字大于这次循环中的最后一个数字，那么指针加1，不断重复这一个过程，指针将指到最后一个数字，如果不是的话，就说明该序列不是搜索树的后续遍历序列，如果大循环结束方法也没有返回假，那么返回应该为真，talk is cheap，show you the code !

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence==null || sequence.length==0)
            return false;
        for(int rootIndex=sequence.length-1;rootIndex>=0;rootIndex--){
            int i = 0;
            for(;sequence[i]<sequence[rootIndex] && i<=sequence.length-1;i++){}
            for(;sequence[i]>sequence[rootIndex] && i<=sequence.length-1;i++){}
            if(i<rootIndex)
                return false;
        }
        return true;
    }
}
```

# 面试题34_二叉树中和为某一值的路径

题目:输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

解析:

1.使用前序遍历的方式(根左右)，使用三个辅助栈，一个栈tns用于存储节点，一个栈nums用于存储节点数值，一个栈finished用于存储当前对应于tns栈的节点状态(数值0表示该访问左子节点，数值1表示该访问右子节点，数值2表示左右子节点都已经访问完了)

2.使用堆栈可以解决的问题，一定要意识到是否可以使用函数递归来解决

总结:

1.当用到某一个方法的时候，不要急于实现它，先把"宏观"的代码写完再去实现用到的某个方法的具体功能，如博主用到的stacknum方法就是求一个Stack<Integer> s中所有数字加在一起的值，先不要去管它的具体实现，先在代码中调用它，等"宏观"代码块写完之后，我们再来考虑它的实现，这种基于函数的编程思想也很好，值得学习，这样即使我们没有实现调用的具体方法，把主要的代码块推敲之后就可以给面试官查看了

2.因为对象是存在于堆中的，当方法的参数传入的是对象的引用，一不小心就会破坏源对象，所以我们用到了clone功能

3.题目中虽然说要(注意: 在返回值的list中，数组长度大的数组靠前)但是判题程序中并没有这方面的检查，所以我们的arrayListSort方法中并未对输入进行处理也通过了所有测试用例

博主想到的笨方法(非递归方式):

```java
import java.util.ArrayList;
import java.util.Stack;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        ArrayList<ArrayList<Integer>> arrayList = new ArrayList<ArrayList<Integer>>();
        if(root==null)
            return new ArrayList<ArrayList<Integer>>();
        Stack<TreeNode> tns = new Stack<TreeNode>();
        Stack<Integer> nums = new Stack<Integer>();
        Stack<Integer> finished = new Stack<Integer>();
        tns.push(root);
        nums.push(root.val);
        finished.push(0);
        while(tns.size()!=0){
            TreeNode node = tns.peek();
            Integer status = finished.peek();
            if(status==0 && node.left!=null){
               finished.pop();               
               finished.push(1);
               finished.push(0);
               tns.push(node.left);
               nums.push(node.left.val);
            }
            else if(status==0 && node.left==null){
                finished.pop();
                finished.push(1);
            }
            else if(status==1 && node.right!=null){
                finished.pop();               
                finished.push(2);
                finished.push(0);
                tns.push(node.right);
                nums.push(node.right.val);
            }
            else if(status==1 && node.right==null){
                finished.pop();
                finished.push(2);
            }
            else if(status==2 && (node.left==null && node.right==null)){
                if(stacknum(nums)==target){
                    arrayList.add(stackToArrayList(nums));
                }
                tns.pop();
                finished.pop();
                nums.pop();
            }
            else if(status==2){
                tns.pop();
                finished.pop();
                nums.pop();
            }
        }
        return arrayListSort(arrayList);
    }
    public int stacknum(Stack<Integer> s){
        Stack<Integer> news = (Stack<Integer>)s.clone();
        if(news==null || news.size()==0)
            throw new RuntimeException("空栈异常！");
        int num = 0;
        while(news.size()!=0){
            num+=news.pop();
        }
        return num;
    }
    public ArrayList<Integer> stackToArrayList(Stack<Integer> s){
        Stack<Integer> news = (Stack<Integer>)s.clone();
        if(news==null)
            throw new RuntimeException("空指针异常！");
        if(news.size()==0)
            return new ArrayList<Integer>();
        ArrayList<Integer> arr = new ArrayList<Integer>();
        int length = news.size()-1;
        for(int i=0;i<news.size();i++){
            arr.add(0);
        }
        while(news.size()!=0){
            arr.set(length, news.pop());
            length--;
        }
        return arr;
    }
    public ArrayList<ArrayList<Integer>> arrayListSort(ArrayList<ArrayList<Integer>> arr){
        return arr;
    }
}
```

可以用堆栈数据结构解决的问题一般也可以使用函数递归来解决(来源于牛客网高赞回答):

```java
public class Solution {
    private ArrayList<ArrayList<Integer>> listAll = new ArrayList<ArrayList<Integer>>();
    private ArrayList<Integer> list = new ArrayList<Integer>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        if(root == null) return listAll;
        list.add(root.val);
        target -= root.val;
        if(target == 0 && root.left == null && root.right == null)
            listAll.add(new ArrayList<Integer>(list));
        FindPath(root.left, target);
        FindPath(root.right, target);
        list.remove(list.size()-1);
        return listAll;
    }
}
```

# 面试题35_复杂链表的复制

题目:输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

总结:

1.方式1，分为两步，第一步处理next指向的节点，第二步处理random指向的节点，在考虑第二步时，首先我们要找出所有节点的random节点，所以一定有一个遍历链表的循环，在第一步处理next指向的节点中我们已经得到了另外一个链表，怎么处理random指向得节点呢？恐怕某节点的random指向第几个节点，复制链表的该对应节点的random就得指向第几个节点，所以我们就可以搞两个指针，搞一个大循环，在大循环中遍历每一个原链表节点，并且有指针(pfirst)指向原链表某节点时，也要有指针(first)指向复制链表的对应节点，在小循环中，我们从头遍历原链表，寻找哪一个节点是大循环节点的random指向的节点，在小循环中也有两个指针，一个指向原链表(pstart)，另一个指向复制链表(start)，在pstart为大循环节点的random指向节点时，将大循环复制链表节点的random赋值为start，这种方式分为大小循环时间复杂度为O(n*n)

2.方式2，有很多种方式用空间来换取时间，比如说我们搞一个哈希表记录原链表节点与复制链表节点之间的对应关系<N,N'>，这样我们第一步还是处理next指向的节点，之后我们遍历链表节点(原链表和复制链表)，当节点N的random指向为节点S时，我们不用在寻找，我们根据哈希表，找到S的对应节点S'之后将其赋值为复制链表的random处就可以了，所以算法复杂度为O(n)

3.方式3，将每个节点N的复制节点N'链接到该节点N的后边，那么该节点N'的random节点就是节点N的random节点的next节点，之后再将链表拆分即可，算法时间复杂度为O(n)

方式1代码：

```java
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null)
            return null;
        RandomListNode pfirst = pHead;
        RandomListNode head = new RandomListNode(pHead.label);
        RandomListNode first = head;
        while(pfirst!=null){
            if(pfirst.next!=null){
                first.next = new RandomListNode(pfirst.next.label);
            }
            pfirst = pfirst.next;
            first = first.next;
        }
        pfirst = pHead;
        first = head;
        while(pfirst!=null){
            RandomListNode pstart = pHead;
            RandomListNode start = head;
            RandomListNode findNode = pfirst.random;
            while(pstart!=null){
                if(findNode==pstart){
                    first.random = start;
                    break;
                }
                else if(findNode!=pstart){
                    pstart = pstart.next;
                    start = start.next;
                }
            }
            pfirst = pfirst.next;
            first = first.next;
        }
        return head;
    }
}
```

方式2代码:

```java
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;
    RandomListNode(int label) {
        this.label = label;
    }
}
*/
import java.util.HashMap;
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        HashMap<RandomListNode, RandomListNode> hash = new HashMap<RandomListNode, RandomListNode>();
        if(pHead==null)
            return null;
        RandomListNode head = new RandomListNode(pHead.label);
        RandomListNode pfirst = pHead;
        RandomListNode first = head;
        hash.put(pfirst, first);
        while(pfirst!=null){
            if(pfirst.next!=null){
                first.next = new RandomListNode(pfirst.next.label);
                hash.put(pfirst.next, first.next);
            }
            pfirst = pfirst.next;
            first = first.next;
        }
        pfirst = pHead;
        first = head;
        while(pfirst!=null){
            first.random = hash.get(pfirst.random);
            pfirst = pfirst.next;
            first = first.next;
        }
        return head;
    }
}
```

方式3代码:

注意:

1.所有带有三目运算符的地方均有可能出错，有可能忘记使用三目运算符

    cloneNode.random = currentNode.random==null?null:currentNode.random.next;

    cloneNode.next = cloneNode.next==null?null:cloneNode.next.next;

2.最后一个while循环中，注意
            
    currentNode = currentNode.next;

    而不是

    currentNode = cloneNode.next;

    因为currentNode.next的指向已经变化了


```java
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null)
            return null;
        RandomListNode currentNode = pHead;
        while(currentNode!=null){
            RandomListNode currentNodeNext = currentNode.next;
            RandomListNode cloneNode = new RandomListNode(currentNode.label);
            currentNode.next = cloneNode;
            cloneNode.next = currentNodeNext;
            currentNode = currentNodeNext;
        }

        currentNode = pHead;
        while(currentNode!=null){
            RandomListNode cloneNode = currentNode.next;
            cloneNode.random = currentNode.random==null?null:currentNode.random.next;
            currentNode = cloneNode.next;
        }

        currentNode = pHead;
        RandomListNode clonepHead = pHead.next;
        RandomListNode cloneNode = clonepHead;

        while(currentNode!=null){
            cloneNode = currentNode.next;
            currentNode.next = cloneNode.next;
            cloneNode.next = cloneNode.next==null?null:cloneNode.next.next;
            currentNode = currentNode.next;
        }
        return clonepHead;
    }
}
```

# 面试题36_二叉搜索树与双向链表

题目:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向

解析:

1.一个容易想到的方式为，得到二叉搜索树的中序遍历序列，之后再在序列之间建立节点指向

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.ArrayList;
public class Solution {
    ArrayList<TreeNode> array = new ArrayList<TreeNode>();
    public ArrayList<TreeNode> inorder(TreeNode root){
        if(root==null)
            return null;
        inorder(root.left);
        array.add(root);
        inorder(root.right);
        return array;
    }

    public TreeNode Convert(TreeNode pRootOfTree) {
        ArrayList<TreeNode> array = new ArrayList<TreeNode>();
        array = inorder(pRootOfTree);
        if(array==null)
            return null;
        if(array.size()==1)
            return array.get(0);
        for(int i=0;i<array.size();i++){
            if(i!=0 && i!=(array.size()-1)){
                array.get(i).left=array.get(i-1);
                array.get(i).right=array.get(i+1);
            }
            else if(i==0){
               array.get(0).left=null;
               array.get(0).right=array.get(1);

            }
            else if(i==(array.size()-1)){
                array.get(array.size()-1).left = array.get(array.size()-2);
                array.get(array.size()-1).right = null;
            }
        }
        return array.get(0);
    }
}
```

2.基于递归的实现

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree==null)
            return null;
        if(pRootOfTree.left==null && pRootOfTree.right==null)
            return pRootOfTree;
        TreeNode leftHead = Convert(pRootOfTree.left);
        TreeNode leftIndex = leftHead;
        if(leftIndex==null){
            TreeNode rightHead = Convert(pRootOfTree.right);
            pRootOfTree.right = rightHead;
            rightHead.left = pRootOfTree;
            return pRootOfTree;
        }
        while(leftIndex!=null){
            if(leftIndex.right!=null){
                leftIndex = leftIndex.right;
            }
            else
                break;
        }
        leftIndex.right = pRootOfTree;
        pRootOfTree.left = leftIndex;
        TreeNode rightHead = Convert(pRootOfTree.right);
        if(rightHead==null){
            return leftHead;
        }
        else{
            pRootOfTree.right = rightHead;
            rightHead.left = pRootOfTree;
        }
        return leftHead;
    }
}
```

# 面试题38_字符串的排列

题目:输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba

牛客网上某答案:

```java
//1、应用递归，想法很简单，遍历整个字符串，固定每个字符，将除去该字符的子序列
//进行排列，并将结果合并到该字符之后
//2、检测的时候应该忽视了字典排序，感觉是只按照给定字符串的顺序检测的
import java.util.ArrayList;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        ArrayList list = new ArrayList();
        int l = str.length();
        if(l == 0 ) return list;
        if(l == 1){
            list.add(str);
        }else{
            for(int i=0;i<l;i++){
                for(String tmp : Permutation(str.substring(0,i)+str.substring(i+1,l))){
                    String temp = str.charAt(i)+tmp;
                    if(!list.contains(temp)){
                        list.add(temp);
                    }
                }
            }
        }
        //Collections.sort(list);
        return list;
    }
}
```

# 面试题39_数组中出现次数超过一半的数字

解析：

1.一个容易想到的思路为全排序，之后维护两个相距为数组长度一半的指针，当两个指针指向的数字相同时，该数字就是要找的数字

```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array==null || array.length==0)
            return 0;
        Integer[] arr = new Integer[array.length];
        for(int i = 0; i<array.length; i++){
            arr[i] = array[i];
        }
        Sort.mergeSort(arr);
        int lo = 0;
        int hi = lo+array.length/2;
        for(;hi<=(arr.length-1);lo++,hi++){
            if(arr[lo]==arr[hi])
                return arr[lo];
        }
        return 0;
    }
}
class Sort{
    private static Comparable[] aux;
    public static void mergeSort(Comparable[] arr){
        if(arr==null || arr.length==0)
            return ;
        aux = new Comparable[arr.length];
        mergeSort(arr, 0, arr.length-1);
    }
    private static void mergeSort(Comparable[] arr, int lo, int hi){
        if(lo>=hi)
            return;
        int mid = (lo+hi)/2;
        mergeSort(arr, lo, mid);
        mergeSort(arr, mid+1, hi);
        merge(arr, lo, mid, hi);
    }
    private static void merge(Comparable[] arr, int lo, int mid, int hi){
        int i = lo;
        int j = mid+1;
        for(int k=lo;k<=hi;k++){
            aux[k]=arr[k];
        }
        for(int k=lo;k<=hi;k++){
            if(i>mid)    arr[k] = aux[j++];
            else if(j>hi)    arr[k] = aux[i++];
            else if(less(arr[i], arr[j]))    arr[k] = aux[i++];
            else                             arr[k] = aux[j++];
        }
    }
    private static boolean less(Comparable t, Comparable w){
        return t.compareTo(w)<0;
    }
}
```

# 面试题40_最小的k个数

题目:输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

终于来到了大名鼎鼎的TOPK问题

方式1:全排序，选取其中的TOPK个数;但是这种方式的缺点是明显的，就是非TOPK的数是不需要排序的，我们做了一些无用功，时间复杂度为O(n*log(n))(快排的平均情况)

方式2:冒泡排序，冒出TOPK个数就可以了，代码如下；这种方式避免了将非TOPK的数字也进行排序，时间复杂度为O(n*k)

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> al = new ArrayList<Integer>();
        if(input==null || input.length==0)
            return new ArrayList<Integer>();
        if(k<=0 || k>input.length)
            return new ArrayList<Integer>();
        for(int i=0;i<k;i++){
            for(int j=input.length-1;j>i;j--){
                if(input[j]<input[j-1])
                    swap(input, j, j-1);
            }
        }
        for(int i=0;i<k;i++){
            al.add(input[i]);
        }
        return al;
    }
     public void swap(int[] arr, int i, int j){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
}
```

方式3:利用小顶堆/大顶堆，时间复杂度为O(n*log(k))

```java
import java.util.ArrayList;
public class Solution {

    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k){
        if(input==null || input.length==0)
            return new ArrayList<Integer>();
        if(k<=0 || k>input.length)
            return new ArrayList<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        for(int i=input.length-1;i>=1;i--){
            if(input[i]<input[(i-1)/2])
                swap(input, i, (i-1)/2);
        }
        drop(input, input.length-1);
        for(int i=0;i<k;i++){
            swap(input, 0, input.length-1-i);
            drop(input, input.length-1-i-1);
            al.add(input[input.length-1-i]);
        }
        return al;
    }
    public void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public void drop(int[] arr, int endIndex){
        int i = 0;
        while((2*i+1)<=endIndex && (2*i+2)<=endIndex){
            if(arr[i]<arr[2*i+1] && arr[i]<arr[2*i+2])
                break;
            if(arr[2*i+1]<arr[2*i+2]){
                swap(arr, i, 2*i+1);
                i = 2*i+1;
            }
            else{
                swap(arr, i, 2*i+2);
                i = 2*i+2;
            }
        }
        if((2*i+1)<=endIndex){
            if(arr[i]>arr[2*i+1])
                swap(arr, i, 2*i+1);
        }
    }
}
```

# 面试题42_连续子数组的最大和

题目:输入一个整形数组，数组里有正数也有负整数。数组中的一个或多个数字组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if(array==null || array.length==0)
            throw new RuntimeException("数组不可以为空");
        int max = array[0];
        int num = array[0];
        for(int i=1 ; i<array.length;i++){
            num+=array[i];
            if(num<array[i]){
                num = array[i];
            }
            max = max>num?max:num;
        }
        return max;
    }
}
```

# 面试题56_数组中数字出现的次数

题目一：数组中只出现一次的两个数字

一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现过一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)

提示：

1.如果只有一个数字只出现了一次，其他数字均出现了两次，该如何编写程序

2.所有数字异或的结果肯定不会是0，可以根据右边数第一个不为1的位置将数组分为两组

```java
    //数组num1和num2用于接收只出现过一次的两个数字
    static void findNumsApperOnce(int[] arr, int[] num1, int[] num2){
        if(arr.length < 2)
            return;
        num1[0] = arr[0];
        num2[0] = arr[1];
        int temp = arr[0];
        for(int i = 0;i<arr.length;i++){
            temp = temp^arr[i];
        }
        int pos;
        for(pos = 0;(temp&1)!=1;pos++)
            temp = temp>>1;
        for(int i=0;i<arr.length;i++){
            if((arr[i]>>pos)==0)
                num1[0]^=arr[i];
            else
                num2[0]^=arr[i];
        }
    }
```

题目二：数组中唯一只出现一次的数字

在一个数组中出=除一个数字只出现一次外，其他数字都出现了三次，请找出那个只出现一次的数字

解析：

1.使用位运算。将所有数字的二进制表示按位相加，如果某位是3的倍数，则表示只出现一次的那个数字在该位上为0，否则为1

2.常规解法：

    1.将数组排序，从排序了的数组找是很容易的，排序算法的话需要O(nlogn)时间

    2.用一个哈希表来记录每个数字出现的次数，但是哈希表需要O(n)的空间  

3.我们下面实现的算法的时间效率为O(n)，我们需要一个长度为32的辅助数组，因为辅助数组的长度是固定的，所以空间复杂度为O(1)

```java
    static int findNumberApperingOnce(int[] arr){
            int[] bit = new int[32];
            for(int i=0;i<arr.length;i++){
                int temp = 1;
                for(int j=0;j<32;j++){
                    bit[j]+=(arr[i]&(temp<<j))>>>j;
                }
            }
            int res = 0;
            for(int i=0;i<32;i++){
                if(bit[i]%3==1)
                    res+=(1<<i);
            }
            return res;
        }
```

# 堆排序

1.利用大顶堆进行排序，sort方法与sink方法所用的代码来源于"算法第四版"，都很惊艳

2.与"算法第四版"不同之一为输入的要排序的数组从0索引开始

```java
public class HeapSort{
    public static void sort(Comparable[] arr){
        if(arr==null || arr.length==0)
            return ; 
        int len = arr.length-1;
        for(int k =(len-1)/2;k>=0;k--){
            sink(arr, 0, len);
        }
        while(len>0){
            swap(arr, 0, len--);
            sink(arr, 0, len);
        }
    }
    private static void sink(Comparable[] arr, int from, int to){
        int k = from;
        while((2*k+1)<=to){
            int j = 2*k+1;
            if(j<to && less(arr, j, j+1))    j++;
            if(!less(arr, k, j))           break;
            swap(arr, k, j);
            k = j;  
        }
    }
    private static void swap(Comparable[] arr, int i, int j){
        Comparable temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    private static boolean less(Comparable[] arr, int i, int j){
        return arr[i].compareTo(arr[j])<0;
    }
}
/*
class Test1{
    public static void main(String[] args){
        Integer[] arr = {1,9,8,7,3,5,4,6,2};
        HeapSort.sort(arr);
        for(int i=0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
    }
}
*/
```

参考习题:

* [面试题40_最小的k个数](#面试题40_最小的k个数)

# 归并排序

```java
public class MergeSort{
    private static Comparable[] aux;
    public static void sort(Comparable[] arr){
        aux = new Comparable[arr.length];
        sort(arr, 0, arr.length-1);
    }
    private static void sort(Comparable[] arr, int lo, int hi){
        if(lo>=hi)
            return;
        int mid = (lo+hi)/2;
        sort(arr, lo, mid);
        sort(arr, mid+1, hi);
        merge(arr, lo, mid , hi);
    }
    private static void merge(Comparable[] arr, int lo, int mid, int hi){
        for(int k=lo;k<=hi;k++){
            aux[k] = arr[k];
        }
        int i = lo;
        int j = mid+1;
        for(int k=lo;k<=hi;k++){
            if(i>mid)      arr[k] = aux[j++];
            else if(j>hi)        arr[k] = aux[i++]; 
            else if(less(arr, i, j))     arr[k] = aux[i++];
            else                        arr[k] = aux[j++];
        }
    }
    private static boolean less(Comparable[] arr, int i, int j){
        return arr[i].compareTo(arr[j])<0;
    }
}
/*
class Test2{
    public static void main(String[] args){
        Integer[] arr = {1,9,8,7,3,5,4,6,2};
        HeapSort.sort(arr);
        for(int i=0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
    }
}
*/
```





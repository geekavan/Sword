牛客网版目录
* [注意事项](#注意事项)
* [二维数组中的查找](#面试题04_二维数组中的查找)
* [替换空格](#面试题05_替换空格)
* [从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [重建二叉树](#面试题07_重建二叉树)
* [用两个栈实现队列](#面试题09_用两个栈实现队列)
* [甜点](#第一星期甜点)
    * [length属性与length()函数](#length属性与length函数)

剑指Offer版目录
* [注意事项](#注意事项)
* [面试题04_二维数组中的查找](#面试题04_二维数组中的查找)
* [面试题05_替换空格](#面试题05_替换空格)
* [面试题06_从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [面试题07_重建二叉树](#面试题07_重建二叉树)
* [面试题09_用两个栈实现队列](#面试题09_用两个栈实现队列)
* [面试题16_数值的整数次方](#面试题16_数值的整数次方)
* [面试题15_二进制中1的个数](#面试题15_二进制中1的个数)
* [面试题56_数组中数字出现的次数](#面试题56_数组中数字出现的次数)

# 注意事项

1.如无特别说明，方法均写在了Sword类中，测试代码均写在了Test类中，有很多方法直接在牛客网上书写并没有对应的测试代码

# 面试题04_二维数组中的查找
题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

```java
    public boolean find(int target, int [][] array) {
        int r = array.length-1;
        int c = 0;
        while(r>-1 && c<array[0].length){
            if(target==array[r][c])
                return true;
            else if(target>array[r][c])
                c++;
            else
                r--;
        }
        return false;
    }
```

# 面试题05_替换空格

题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy

解析：

1.我们肯定要用到空格判断，那么怎么从字符串里边读取每个字符呢？查找API以下是我们可能会用到的方法

    StringBuffer(int capacity)
          构造一个不带字符，但具有指定初始容量的字符串缓冲区
    char charAt(int index)
          返回此序列中指定索引处的 char 值
    int length()
          返回长度（字符数）
    void setCharAt(int index, char ch)
          将给定索引处的字符设置为 ch
    void setLength(int newLength)
          设置字符序列的长度
    String toString()
          返回此序列中数据的字符串表示形式

其中的setLength方法：

```java
setLength
public void setLength(int newLength)设置字符序列的长度。序列将被更改为一个新的字符序列，新序列的长度由参数指定。对于每个小于 newLength 参数的非负索引 k，如果 k 小于原字符序列的长度，则新字符序列索引 k 处的字符与原字符序列索引 k 处的字符相同；否则，新字符序列索引 k 处的字符将是 null 字符 '\u0000'。换句话说，如果 newLength 参数小于当前长度，则长度将更改为指定的长度。
如果 newLength 参数大于或等于当前长度，则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数。

newLength 参数必须大于或等于 0。


参数：
newLength - 新长度
抛出：
IndexOutOfBoundsException - 如果 newLength 参数为负。
另请参见：
length()
```

2.还需明确一点就是容量和长度是两个不同的概念

```java
length
public int length()返回长度（字符数）。

指定者：
接口 CharSequence 中的 length
返回：
此对象表示的当前字符序列的长度。

--------------------------------------------------------------------------------

capacity
public int capacity()返回当前容量。容量指可用于最新插入的字符的存储量，超过这一容量就需要再次进行分配。 

返回：
当前容量。
```

所以有

```java
        StringBuffer str = new StringBuffer(13);
        System.out.println(str.length());
        System.out.println(str.capacity());

/*
$ java Test
0
13
*/
```

明确了这个知识点之后就知道如下程序是错误的了

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        StringBuffer newStr = new StringBuffer(newStrLength);
        int index = newStr.length()-1;//这里的newStr.length()为0而不是newStrLength
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                newStr.setCharAt(index--,'0');
                newStr.setCharAt(index--,'2');
                newStr.setCharAt(index--,'%');
            }
            else
                newStr.setCharAt(index--,str.charAt(i));
        }
        return newStr.toString();
    }
```


3.思路：我们可以先遍历一遍数组，查看有多少空格，再将字符序列长度设置为替换空格之后的长度，从后向前求解新的字符串

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        str.setLength(newStrLength);
        int index = newStrLength-1;
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                str.setCharAt(index--,'0');
                str.setCharAt(index--,'2');
                str.setCharAt(index--,'%');
            }
            else
                str.setCharAt(index--,str.charAt(i));
        }
        return str.toString();
    }
```

# 面试题06_从尾到头打印链表

题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList

### 自己的方法

自己的思路：

1.先遍历一遍链表，查看链表中元素的个数listNodeLength

2.再新建一个ArrayList对象，使其长度为listNodeLength

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面

问题：

可以新建一个ArrayList对象，使其容量为listNodeLength但是却不能使其元素数为listNodeLength，如下：

```java
ArrayList<Integer> al = new ArrayList<Integer>(13);
al.add(1,12);
/*
$ java Test
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 1, Size: 0
        at java.util.ArrayList.rangeCheckForAdd(Unknown Source)
        at java.util.ArrayList.add(Unknown Source)
        at Test.main(Test.java:16)
*/
```

如上虽然容量为13，但是Size依然为0，并没有1的索引，所以改进思路为：

1.新建立一个ArrayList对象

2.遍历一遍链表，将链表上的值依次存储在ArrayList对象里边

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面(改变原ArrayList的值)

```java
public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        ListNode head = listNode;
        while(listNode!=null){
            al.add(listNode.val);
            listNode = listNode.next;
        }
        for(int i=al.size()-1;i>-1;i--){
            al.set(i, head.val);
            head = head.next;
        }
        return al;
    }
```

### 答案1_利用栈

解析：

1.从头到尾遍历一遍链表，先遍历到的后输出，后遍历到的先输出，这是明显的先进后出规则，我们可以使用栈结构来实现

相关API
    boolean empty()
          测试堆栈是否为空
    E pop()
          移除堆栈顶部的对象，并作为此函数的值返回该对象
    E push(E item)
          把项压入堆栈顶部

```java
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        Stack<Integer> s = new Stack<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        while(listNode!=null){
            s.push(listNode.val);
            listNode = listNode.next;
        }
        while(!s.empty()){
            al.add(s.pop());
        }
        return al;
    }
```

### 答案2_利用递归

我们始终要记住一点：递归的本质就是一种栈结构，所以上述方式完全可以用递归方法改写

```java
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode!=null){
            //每次压栈时，里边都存有下一次压栈后printListFromTailToHead返回的ArrayList的引用变量al，在al里边add这一次压栈的节点的val值，返回al
            ArrayList<Integer> al = printListFromTailToHead(listNode.next);
            al.add(listNode.val);
            return al;
        }
        return new ArrayList();
    }
}
```

# 面试题07_重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

```java
public static TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0)
            return null;
        TreeNode root = new TreeNode(pre[0]);
        int rootIndex = 0;
        while(pre[0]!=in[rootIndex]){
            rootIndex++;
        }
        int[] leftIn = Arrays.copyOfRange(in, 0, rootIndex);
        int[] rightIn = Arrays.copyOfRange(in, rootIndex+1, in.length);
        int[] leftPre = Arrays.copyOfRange(pre, 1, rootIndex+1);
        int[] rightPre = Arrays.copyOfRange(pre, rootIndex+1, pre.length);
        root.left = reConstructBinaryTree(leftPre , leftIn);
        root.right = reConstructBinaryTree(rightPre ,rightIn);
        return root;
    }
```

# 面试题09_用两个栈实现队列

```java
import java.util.Stack;

class Queue{
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public void push(int node) {
         while(!stack2.empty()){
            stack1.push(stack2.pop());
        }
        stack1.push(node);

    }
    public int pop() {
        while(!stack1.empty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```

# 第一星期甜点

# length属性与length函数

1.length为属性，求得数组长度；length()为函数，用于求字符串的长度；size()函数用于求泛型类的元素多少

2.为什么数组的长度为属性，而字符串的长度(或者说泛型类的元素个数)为函数？

这是因为数组的长度一旦确定并不可以改动，而字符串长度(或者说泛型类的元素个数)可以改动，示例如下：

```java
import java.util.ArrayList;
class LengthTest{
    public static void main(String[] args){
        int[] arr = new int[8];
        int arrLength = arr.length;
        System.out.println("arrLength: "+arrLength);

        String s = new String();
        s = " hello world ";
        System.out.println("sLength: "+s.length());
        s = s.trim();
        System.out.println("sLength: "+s.length());

        ArrayList<Integer> arrList = new ArrayList<Integer>();
        System.out.println("arrListLength: "+arrList.size());
        arrList.add(5);
        System.out.println("arrListLength: "+arrList.size());
    }
}
/*
$ java LengthTest
arrLength: 8
sLength: 13
sLength: 11
arrListLength: 0
arrListLength: 1
*/
```

# 面试题16_数值的整数次方

题目：实现函数double Power(double base, int exponent)，求base得exponent次方。不得使用库函数，同时不需要考虑大数问题

解析：

1.base为0的时候，exponent不可以同时为0，这个时候程序的规定输出要和面试官说明(本程序此种情况输出为0)，表明我们考虑到了这种情况，其实博主觉得可以考虑在此种情况下输出异常

2.当base为0的时候，exponent不为0则输出为0

3.注意exponent的取值，取正值，取负值，取负值的结果等于其绝对值的power取倒数，取0，结果为1

4.考虑高效算法

![power](https://github.com/geekavan/Sword/blob/master/power.png)

5.可以通过位运算判断一个数的奇偶，(exponent & 1)==0

综上，我们有：

```java
public class Sword{
    static double power(double base, int exponent){
        if(base==0 && exponent==0)
            return 0;
        if(base==0)
            return 0;
        if(exponent<0)
            return 1/(power(base, -exponent));
        if(exponent==0)
            return 1;
        if(exponent%2==0){
            double temp = power(base, exponent/2);
            return temp*temp;
        }
        else
            return base*power(base, (exponent-1));
    }
}
class Test{
    public static void main(String[] args){
        double s16  = Sword.power(5, -2);
        System.out.println(s16);
    }
}
/*
$ java Test
0.04
*/
```

# 面试题15_二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数

解析：

1.把一个整数减去1，之后再和原来那个整数做位与运算，这个操作相当于把这个整数的二进制表示的最右边的1置为0，很多问题都可以用这个trick来解决

```java
    static int numberOf1(int number){
        int result = 0;
        while((number&(number-1))!=0){
            result++;
            number = number&(number-1);
        }
        return result;
    }
```

# 面试题56_数组中数字出现的次数

题目一：数组中只出现一次的两个数字

一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现过一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)

提示：

1.如果只有一个数字只出现了一次，其他数字均出现了两次，该如何编写程序

2.所有数字异或的结果肯定不会是0，可以根据右边数第一个不为1的位置将数组分为两组

```java
    //数组num1和num2用于接收只出现过一次的两个数字
    static void findNumsApperOnce(int[] arr, int[] num1, int[] num2){
        if(arr.length < 2)
            return;
        num1[0] = arr[0];
        num2[0] = arr[1];
        int temp = arr[0];
        for(int i = 0;i<arr.length;i++){
            temp = temp^arr[i];
        }
        int pos;
        for(pos = 0;(temp&1)!=1;pos++)
            temp = temp>>1;
        for(int i=0;i<arr.length;i++){
            if((arr[i]>>pos)==0)
                num1[0]^=arr[i];
            else
                num2[0]^=arr[i];
        }
    }
```

题目二：数组中唯一只出现一次的数字

在一个数组中出=除一个数字只出现一次外，其他数字都出现了三次，请找出那个只出现一次的数字

解析：

1.使用位运算。将所有数字的二进制表示按位相加，如果某位是3的倍数，则表示只出现一次的那个数字在该位上为0，否则为1

2.常规解法：

    1.将数组排序，从排序了的数组找是很容易的，排序算法的话需要O(nlogn)时间

    2.用一个哈希表来记录每个数字出现的次数，但是哈希表需要O(n)的空间  

3.我们下面实现的算法的时间效率为O(n)，我们需要一个长度为32的辅助数组，因为辅助数组的长度是固定的，所以空间复杂度为O(1)

```java
    static int findNumberApperingOnce(int[] arr){
            int[] bit = new int[32];
            for(int i=0;i<arr.length;i++){
                int temp = 1;
                for(int j=0;j<32;j++){
                    bit[j]+=(arr[i]&(temp<<j))>>>j;
                }
            }
            int res = 0;
            for(int i=0;i<32;i++){
                if(bit[i]%3==1)
                    res+=(1<<i);
            }
            return res;
        }
```
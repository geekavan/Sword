牛客网版目录
* [注意事项](#注意事项)
* [编程题窍门](#编程题窍门)
* [二维数组中的查找](#面试题04_二维数组中的查找)
* [替换空格](#面试题05_替换空格)
* [从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [重建二叉树](#面试题07_重建二叉树)
* [用两个栈实现队列](#面试题09_用两个栈实现队列)
* [甜点](#第一星期甜点)
    * [length属性与length()函数](#length属性与length函数)
* [旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [斐波那契数列](#面试题10_斐波那契数列)
    * [青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [变态跳台阶](#本题扩展变态跳台阶)
    * [矩形覆盖](#相关题目矩形覆盖)
* [二进制中1的个数](#面试题15_二进制中1的个数)
* [数值的整数次方](#面试题16_数值的整数次方)
* [调整数组顺序使奇数位于偶数前面](#面试题21_调整数组顺序使奇数位于偶数前面)
* [链表中倒数第k个节点](#面试题22_链表中倒数第k个节点)
* [反转链表](#面试题24_反转链表)
* [合并两个排序的链表](#面试题25_合并两个排序的链表)
* [树的子结构](#面试题26_树的子结构)
* [二叉树的镜像](#面试题27_二叉树的镜像)
* [顺时针打印矩阵](#面试题29_顺时针打印矩阵)
* [包含min函数的栈](#面试题30_包含min函数的栈)
* [栈的压入_弹出序列](#面试题31_栈的压入_弹出序列)
* [从上到下打印二叉树](#面试题32_从上到下打印二叉树)


剑指Offer版目录
* [注意事项](#注意事项)
* [编程题窍门](#编程题窍门)
* [面试题04_二维数组中的查找](#面试题04_二维数组中的查找)
* [面试题05_替换空格](#面试题05_替换空格)
* [面试题06_从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [面试题07_重建二叉树](#面试题07_重建二叉树)
* [面试题09_用两个栈实现队列](#面试题09_用两个栈实现队列)
* [面试题10_斐波那契数列](#面试题10_斐波那契数列)
    * [题目二青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [本题扩展变态跳台阶](#本题扩展变态跳台阶)
    * [相关题目矩形覆盖](#相关题目矩形覆盖)
* [面试题11_旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [面试题15_二进制中1的个数](#面试题15_二进制中1的个数)
* [面试题16_数值的整数次方](#面试题16_数值的整数次方)
* [面试题21_调整数组顺序使奇数位于偶数前面](#面试题21_调整数组顺序使奇数位于偶数前面)
* [面试题22_链表中倒数第k个节点](#面试题22_链表中倒数第k个节点)
* [面试题23_反转链表](#面试题24_反转链表)
* [面试题25_合并两个排序的链表](#面试题25_合并两个排序的链表)
* [面试题26_树的子结构](#面试题26_树的子结构)
* [面试题27_二叉树的镜像](#面试题27_二叉树的镜像)
* [面试题29_顺时针打印矩阵](#面试题29_顺时针打印矩阵)
* [面试题30_包含min函数的栈](#面试题30_包含min函数的栈)
* [面试题31_栈的压入_弹出序列](#面试题31_栈的压入_弹出序列)
* [面试题32_从上到下打印二叉树](#面试题32_从上到下打印二叉树)
* [面试题56_数组中数字出现的次数](#面试题56_数组中数字出现的次数)

# 注意事项

1.如无特别说明，方法均写在了Sword类中，测试代码均写在了Test类中，有很多方法直接在牛客网上书写并没有对应的测试代码

2.每道题的总结或解析部分给出了这道题应该注意的点，或者说这道题考察的点

# 编程题窍门

1.在程序的开头单独书写特殊输入的处理代码。

如当输入为数组的时候，数组为空怎么办，当输入为链表的时候，链表为空怎么办，当某个方法为求某个底数的指数次方，而输入的底数和指数都为0时怎么办。即使下面的程序段包含了特殊输入的处理代码也要单独写出来，一个是在面试中明确地告诉面试官，我们考虑了特殊输入的情况，我们有注意代码鲁棒性的意识，另一个是在工作中也使得代码更加清晰，可读性更强

2.在编写链表等相关代码的时候，不要从"开头"考虑如何编写代码，而是要从"中间"考虑如何编写代码。

如当你以这种想法考虑面试题25合并两个排序的链表的时候，你就要想，你已经有了合并好的链表的头节点head，还有没合并的排序链表头节点list1和list2，那么接下来你该如何编写代码呢？从这个角度出发，编写完循环内的代码，再处理一下开头就会容易的多

# 面试题04_二维数组中的查找
题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

```java
    public boolean find(int target, int [][] array) {
        int r = array.length-1;
        int c = 0;
        while(r>-1 && c<array[0].length){
            if(target==array[r][c])
                return true;
            else if(target>array[r][c])
                c++;
            else
                r--;
        }
        return false;
    }
```

# 面试题05_替换空格

题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy

解析：

1.我们肯定要用到空格判断，那么怎么从字符串里边读取每个字符呢？查找API以下是我们可能会用到的方法

    StringBuffer(int capacity)
          构造一个不带字符，但具有指定初始容量的字符串缓冲区
    char charAt(int index)
          返回此序列中指定索引处的 char 值
    int length()
          返回长度（字符数）
    void setCharAt(int index, char ch)
          将给定索引处的字符设置为 ch
    void setLength(int newLength)
          设置字符序列的长度
    String toString()
          返回此序列中数据的字符串表示形式

其中的setLength方法：

```java
setLength
public void setLength(int newLength)设置字符序列的长度。序列将被更改为一个新的字符序列，新序列的长度由参数指定。对于每个小于 newLength 参数的非负索引 k，如果 k 小于原字符序列的长度，则新字符序列索引 k 处的字符与原字符序列索引 k 处的字符相同；否则，新字符序列索引 k 处的字符将是 null 字符 '\u0000'。换句话说，如果 newLength 参数小于当前长度，则长度将更改为指定的长度。
如果 newLength 参数大于或等于当前长度，则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数。

newLength 参数必须大于或等于 0。


参数：
newLength - 新长度
抛出：
IndexOutOfBoundsException - 如果 newLength 参数为负。
另请参见：
length()
```

2.还需明确一点就是容量和长度是两个不同的概念

```java
length
public int length()返回长度（字符数）。

指定者：
接口 CharSequence 中的 length
返回：
此对象表示的当前字符序列的长度。

--------------------------------------------------------------------------------

capacity
public int capacity()返回当前容量。容量指可用于最新插入的字符的存储量，超过这一容量就需要再次进行分配。 

返回：
当前容量。
```

所以有

```java
        StringBuffer str = new StringBuffer(13);
        System.out.println(str.length());
        System.out.println(str.capacity());

/*
$ java Test
0
13
*/
```

明确了这个知识点之后就知道如下程序是错误的了

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        StringBuffer newStr = new StringBuffer(newStrLength);
        int index = newStr.length()-1;//这里的newStr.length()为0而不是newStrLength
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                newStr.setCharAt(index--,'0');
                newStr.setCharAt(index--,'2');
                newStr.setCharAt(index--,'%');
            }
            else
                newStr.setCharAt(index--,str.charAt(i));
        }
        return newStr.toString();
    }
```


3.思路：我们可以先遍历一遍数组，查看有多少空格，再将字符序列长度设置为替换空格之后的长度，从后向前求解新的字符串

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        str.setLength(newStrLength);
        int index = newStrLength-1;
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                str.setCharAt(index--,'0');
                str.setCharAt(index--,'2');
                str.setCharAt(index--,'%');
            }
            else
                str.setCharAt(index--,str.charAt(i));
        }
        return str.toString();
    }
```

# 面试题06_从尾到头打印链表

题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList

### 自己的方法

自己的思路：

1.先遍历一遍链表，查看链表中元素的个数listNodeLength

2.再新建一个ArrayList对象，使其长度为listNodeLength

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面

问题：

可以新建一个ArrayList对象，使其容量为listNodeLength但是却不能使其元素数为listNodeLength，如下：

```java
ArrayList<Integer> al = new ArrayList<Integer>(13);
al.add(1,12);
/*
$ java Test
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 1, Size: 0
        at java.util.ArrayList.rangeCheckForAdd(Unknown Source)
        at java.util.ArrayList.add(Unknown Source)
        at Test.main(Test.java:16)
*/
```

如上虽然容量为13，但是Size依然为0，并没有1的索引，所以改进思路为：

1.新建立一个ArrayList对象

2.遍历一遍链表，将链表上的值依次存储在ArrayList对象里边

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面(改变原ArrayList的值)

```java
public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        ListNode head = listNode;
        while(listNode!=null){
            al.add(listNode.val);
            listNode = listNode.next;
        }
        for(int i=al.size()-1;i>-1;i--){
            al.set(i, head.val);
            head = head.next;
        }
        return al;
    }
```

### 答案1_利用栈

解析：

1.从头到尾遍历一遍链表，先遍历到的后输出，后遍历到的先输出，这是明显的先进后出规则，我们可以使用栈结构来实现

相关API

    boolean empty()
          测试堆栈是否为空
    E pop()
          移除堆栈顶部的对象，并作为此函数的值返回该对象
    E push(E item)
          把项压入堆栈顶部

```java
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        Stack<Integer> s = new Stack<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        while(listNode!=null){
            s.push(listNode.val);
            listNode = listNode.next;
        }
        while(!s.empty()){
            al.add(s.pop());
        }
        return al;
    }
```

### 答案2_利用递归

我们始终要记住一点：递归的本质就是一种栈结构，所以上述方式完全可以用递归方法改写

```java
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode!=null){
            //每次压栈时，里边都存有下一次压栈后printListFromTailToHead返回的ArrayList的引用变量al，在al里边add这一次压栈的节点的val值，返回al
            ArrayList<Integer> al = printListFromTailToHead(listNode.next);
            al.add(listNode.val);
            return al;
        }
        return new ArrayList();
    }
}
```

# 面试题07_重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

```java
public static TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0)
            return null;
        TreeNode root = new TreeNode(pre[0]);
        int rootIndex = 0;
        while(pre[0]!=in[rootIndex]){
            rootIndex++;
        }
        int[] leftIn = Arrays.copyOfRange(in, 0, rootIndex);
        int[] rightIn = Arrays.copyOfRange(in, rootIndex+1, in.length);
        int[] leftPre = Arrays.copyOfRange(pre, 1, rootIndex+1);
        int[] rightPre = Arrays.copyOfRange(pre, rootIndex+1, pre.length);
        root.left = reConstructBinaryTree(leftPre , leftIn);
        root.right = reConstructBinaryTree(rightPre ,rightIn);
        return root;
    }
```

# 面试题09_用两个栈实现队列

```java
import java.util.Stack;

class Queue{
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public void push(int node) {
         while(!stack2.empty()){
            stack1.push(stack2.pop());
        }
        stack1.push(node);

    }
    public int pop() {
        while(!stack1.empty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```

# 第一星期甜点

# length属性与length函数

1.length为属性，求得数组长度；length()为函数，用于求字符串的长度；size()函数用于求泛型类的元素多少

2.为什么数组的长度为属性，而字符串的长度(或者说泛型类的元素个数)为函数？

这是因为数组的长度一旦确定并不可以改动，而字符串长度(或者说泛型类的元素个数)可以改动，示例如下：

```java
import java.util.ArrayList;
class LengthTest{
    public static void main(String[] args){
        int[] arr = new int[8];
        int arrLength = arr.length;
        System.out.println("arrLength: "+arrLength);

        String s = new String();
        s = " hello world ";
        System.out.println("sLength: "+s.length());
        s = s.trim();
        System.out.println("sLength: "+s.length());

        ArrayList<Integer> arrList = new ArrayList<Integer>();
        System.out.println("arrListLength: "+arrList.size());
        arrList.add(5);
        System.out.println("arrListLength: "+arrList.size());
    }
}
/*
$ java LengthTest
arrLength: 8
sLength: 13
sLength: 11
arrListLength: 0
arrListLength: 1
*/
```

# 面试题11_旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

NOTE：给出的所有元素都大于0，若数组大小为0，请返回0

总结：

1.O(n)的方法很容易想到，但是并不是最优的

2.要注意并利用到旋转数组被分为了两个排序数组的特征

3.要考虑到{1,0,1,1,1,1}这类若干元素相等的情况

4.要考虑到{0,1,2,3,4,5,6}这类，把一个数组最开始的**0**个元素搬到数组的末尾的特殊情况

很容易想到当出现一个数大于后面的数字，那么后面的那个数字就是最小的数，程序如下，但是这种方法的时间复杂度为O(n)

1.该方法没有用到太多的旋转数组的特性，只认识到了"当出现一个数大于后面的数字，那么后面的那个数字就是最小的数"，其实还应该认识到，**旋转数组旋转之后变为了两个排序数组**

```java
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        else{
            for(int i=0;i<array.length-1;){
                if(array[i]>array[++i])
                    return array[i];
            }
        }
        return -1;//当输入为非法数组(非符合要求的旋转数组)的时候的输出，这点可以和面试官确认一下，表示我们考虑到了这种情况
    }
```

又想到能否使用递归呢？

```java
    public int minNumberInRotateArray(int [] array) {
        int index = array.length/2;
        if(index==0)
            return -1;
        if(array[index-1]>array[index])
            return array[index];
        int left = minNumberInRotateArray(Arrays.copyOfRange(array, 0, index));
        int right = minNumberInRotateArray(Arrays.copyOfRange(array, index, array.length));
        if(left!=-1)
            return left;
        if(right!=-1)
            return right;
        return -1;
    }
```

牛客网中一java版高赞回答，是错误的，没有考虑到特殊情况，如{1,0,1,1,1,1}，但是该方法注意到了旋转数组为两个排序数组的特性(注意还有不旋转的排序数组也是旋转数组)，也没有考虑到{0,1,2,3,4,5,6,7,8,9}的情况

```java
public class Test11{
    public static void main(String[] args){
        int[] arr = {1,0,1,1,1,1,1};
        int min = minNumberInRotateArray(arr);
        System.out.println(min);
    }
    public static int minNumberInRotateArray(int[] array) {
        if (array.length == 0)
            return 0;
        int left = 0;
        int right = array.length - 1;
        int middle = -1;
        while (array[left]>=array[right]) {
            if(right-left==1){
                middle = right;
                break;
            }
            middle = left + (right - left) / 2;
            if (array[middle] >= array[left]) {
                left = middle;
            }
            if (array[middle] <= array[right]) {
                right = middle;
            }
        }
        return array[middle];
    }
}
```

上述程序会陷入死循环，将其修改后为：

```java
public class Test11_1{
    public static void main(String[] args){
        int[] arr0 = {1,0,1,1,1,1,1};
        int[] arr1 = {5,6,7,8,0,1,2,3,4};
        int[] arr2 = {0,1,2,3,4,5,6,7,8};
        int min = minNumberInRotateArray(arr1);
        System.out.println(min);
        System.exit(0);
    }
    public static int minNumberInRotateArray(int[] array) {
        if(array==null)
            throw new RuntimeException("数组不可以为空");
        int leftIndex = 0;
        int rightIndex = array.length-1;
        if(array[leftIndex]<array[rightIndex]){
            return array[leftIndex];
        }
        int midIndex;
        while((rightIndex-leftIndex)>1){
            midIndex = (leftIndex + rightIndex)/2;
            int temp;
            if(array[leftIndex] > array[midIndex])
                rightIndex = midIndex;
            else if(array[leftIndex] < array[midIndex])
                leftIndex = midIndex;
            else if((array[leftIndex] == array[midIndex]) || (array[rightIndex] == array[midIndex])){
                temp = leftIndex+1;
                if(array[leftIndex] == array[temp])
                    leftIndex++;
                temp = rightIndex-1;
                if(array[rightIndex] == array[temp])
                    rightIndex--;
            }
        }
        return array[rightIndex];
    }
}
```

# 面试题10_斐波那契数列

题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

总结：

1.递归方式很容易想到，但是会计算重复项，效率不高

2.从第一项计算到第n项可取

3.有更高阶的方式解决此题，比如通项公式等

递归的方式很容易想到

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}
```

但是递归的问题是，一个斐波那契数列项会被多次重复计算，比如计算f(10)=f(9)+f(8)，而计算f(9)的时候又会计算f(8)，导致计算的速度很慢，可以重第一项计算到第n项，就不会出现重复计算的情况

```java
    public static int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        int first = 0;
        int second = 1;
        int temp;
        for(int i=0;i<n;i++){
            first = first+second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
```
### 题目二青蛙跳台阶问题

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target<=0)
            throw new RuntimeException("target必须大于0");
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```

### 本题扩展变态跳台阶

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

解析：用归纳法不难证明答案为2的n次方，但是此题的知识点归类为贪婪算法，查看讨论中，并未发现应用贪婪算法的解法

```java
public class Solution {
    public int JumpFloorII(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于等于1");
        return 1<<(target-1);
    }
}
```

### 相关题目矩形覆盖

题目：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int RectCover(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于0");
        if(target==0)
            return 0;
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```

# 面试题15_二进制中1的个数

题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示

总结：

1.方法一：不断进行无符号右移操作，并且在位移的过程中与1进行位与运算(判断最后一位是否为1)……

2.方法二：利用n&(n-1)相当于把int型的数n的二进制的最后一位设置为0的trick

一个容易想到的思路为，该数与1相与得到最后一位数字，判断其是1还是0，不断右移，判断全部的32位数

```java
public class Solution {
    public int NumberOf1(int n) {
        int numbers = 0;
        while(n!=0){
            if((n&1)==1)
                numbers++;
            n=n>>>1;
        }
        return numbers;
    }
}
```

如果注意到当一个数与该数减去1之后的结果相与，那么就相当于把该数最右边的1置为0的trick之后，程序可以改为：

```java
    static int NumberOf1(int n) {
        int numbers = 0;
        while(n!=0){
            numbers++;
            n=n&(n-1);
        }
        return numbers;
    }
```

# 面试题16_数值的整数次方

题目：实现函数double Power(double base, int exponent)，求base得exponent次方。不得使用库函数，同时不需要考虑大数问题

解析：

1.base为0的时候，exponent不可以同时为0，这个时候程序的规定输出要和面试官说明(本程序此种情况输出为0)，表明我们考虑到了这种情况，其实博主觉得可以考虑在此种情况下输出异常

2.当base为0的时候，exponent不为0则输出为0

3.注意exponent的取值，取正值，取负值，取负值的结果等于其绝对值的power取倒数，取0，结果为1

4.考虑高效算法

![power](https://github.com/geekavan/Sword/blob/master/power.png)

5.可以通过位运算判断一个数的奇偶，(exponent & 1)==0

综上，我们有：

```java
public class Sword{
    static double power(double base, int exponent){
        if(base==0 && exponent==0)
            return 0;
        if(base==0)
            return 0;
        if(exponent<0)
            return 1/(power(base, -exponent));
        if(exponent==0)
            return 1;
        if(exponent%2==0){
            double temp = power(base, exponent/2);
            return temp*temp;
        }
        else
            return base*power(base, (exponent-1));
    }
}
class Test{
    public static void main(String[] args){
        double s16  = Sword.power(5, -2);
        System.out.println(s16);
    }
}
/*
$ java Test
0.04
*/
```

总结：

1.知道如何通过位运算判断一个数为奇数还是偶数

2.知道如何通过位运算将一个数乘以2或除以2

学完异常之后再做此题为

```java
public class Solution {
    public double Power(double base, int exponent) {
        if(base==0 && exponent==0)
            throw new RuntimeException("底数和指数不可以同时为0!");
        if(exponent==0)
            return 1.0;
        if(base==0)
            return 0.0;
        if(exponent<0)
            return 1/Power(base, -exponent);
        if((exponent&1)==0)
            return Power(base,exponent>>1)*Power(base,exponent>>1);
        return base*Power(base,exponent-1);
  }
}
```

# 面试题21_调整数组顺序使奇数位于偶数前面

题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

总结：

1.该题与剑指Offer相比做了改动，剑指Offer第2版中本题并不要求稳定性(相对位置不变)

2.(若不要求稳定性)维护两个指针就可以了，开头一个，结尾一个

3.(若不要求稳定性)该题使博主想起了替换空格的那道题，可以先遍历数组找出奇数和偶数的个数，再在奇数结束位置处维护偶数指针(其实多此一举，直接在开头和结尾维护指针就可以了)

4.(若要求稳定性)直接应用具有稳定性的经典排序算法思路就可以了，下文中演示了此方式(应用插入排序思路)

5.以剑指Offer说法，本题考查程序的可扩展性，那要是负数排前面，非负数排后面呢？要是被3整除的排前面，不被3整除的排后面呢？

解析：应用一个稳定的排序算法思路就可以了，首先想到了插入算法思想

```java
public class Solution {
    public void reOrderArray(int [] array) {
        for(int i=0;i<array.length;i++){
            for(int j = i;(j>0) && ((array[j]&1)==1) && ((array[j-1]&1)==0);j--){
                swap(array, j,j-1);
            }
        }
    }
    public static void swap(int[] arr, int i, int j){
        int temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

考虑到总结中的第5点，程序的可扩展性问题，将程序改为：

```java
public class Solution {
    public void reOrderArray(int [] array) {
        for(int i=0;i<array.length;i++){
            for(int j = i;(j>0) && function(array, j, j-1);j--){
                swap(array, j,j-1);
            }
        }
    }
    public static void swap(int[] arr, int i, int j){
        int temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static boolean function(int[] arr, int i, int j){
        if((arr[i]&1)==1)
            if((arr[j]&1)==0)
                return true;
        return false;
    }
}
```

这样如果改需求的话，可以直接改写function函数就好了

# 面试题22_链表中倒数第k个节点

题目：输入一个链表，输出该链表中倒数第k个结点

总结：

1.该题考查应试者编程的鲁棒性，别忘记了考虑特殊输入，head为null，k小于链表的节点数，k为负数，k为0

解析：

1.博主以前做过这道题，直接想到维护两个相距k的指针就好了

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        ListNode first = head;
        int i;
        for(i=0;(i<k) && (first!=null);i++)
            first = first.next;
        if(i!=k)
            return null;
        while(first!=null){
            head = head.next;
            first = first.next;
        }
        return head;
    }
}
```

上述解法通过了牛客网的检测，但显然是不合适的，当我输入k小于或等于0的时候，返回为空，当我输入k为负数的时候，返回也是空，这合适吗？当输入为负数，滥用这个方法的时候，直接抛出运行时异常！停掉调用者的程序

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null)//考虑到了空指针的情况，当然这一点下边的程序也涵盖了，但是单列出来比较好，一个是告诉面试者我考虑到了这种情况，另一个实际开发的时候也比较清晰，以后都这么写！
            return null;
        if(k<0)//考虑到了k小于0的情况，当然k是否可以等于0，约定俗成就好，这了为了通过牛客网测试没有包含0
            throw new RuntimeException("k必须大于等于0");
        ListNode first = head;
        int i;
        for(i=0;(i<k) && (first!=null);i++)
            first = first.next;
        if(i!=k)//考虑到了链表节点数小于k的情况，至于处理方式也可以选择抛出异常(这类问题都可以和面试官确认)，这里为了通过牛客网测试选择了返回空
            return null;
        while(first!=null){
            head = head.next;
            first = first.next;
        }
        return head;
    }
}
```

# 面试题24_反转链表

题目：输入一个链表，反转链表后，输出新链表的表头

总结：

1.有些问题不要从"头"想，要从"中间位置"想

2.该题考查代码的鲁棒性，可以将特殊输入的处理代码段单列在程序开头，比如博主这里将输入为null的情况的处理单列在程序开始的部分，虽然后续的程序段也可以圆满地解决这个特殊输入，但是单列出来，一个是在面试中告诉面试官，我考虑到了这种情况，另一个是在实际工作中使自己的代码更加清晰易读

解析：

1.从"中间位置"想的话，很容易得到while循环中的代码

2.该题考查代码的鲁棒性，要保证当输入为null，只有一个节点时，代码能够正常执行

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null)
            return null;
        ListNode node = head;
        ListNode first = null;
        while(node!=null){
            ListNode nodeNext = node.next;
            node.next = first;
            first = node;
            node = nodeNext;
        }
        return first;
    }
}
```

# 面试题25_合并两个排序的链表

题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则

解析：

1.考虑特殊输入

2.从"中间开始考虑"，不要从"开头考虑"

总结：

1.我们要注意函数的返回值是什么类型--->ListNode

2.我们要注意如果使用递归的话，递归的那个函数的功能是什么？--->找出头节点list1和list2中值较小的那一个并返回

3.我们要怎么才能保证返回的是单调不减链表？--->一个是返回两个头节点中较小的一个，另一个是该较小的头节点的下一个节点也是下两个排序链表头结点中较小的一个

4.一个递归函数对应一个栈帧，我们要保证该栈帧中返回的是**两个排序链表头结点中较小的一个节点**，该节点的下一个节点也是**下两个排序链表头节点中较小的一个节点**

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1==null)
            return list2;
        if(list2==null)
            return list1;
        ListNode head = new ListNode(0);
        ListNode first=null;
        for(int i=0;((list1!=null)&&(list2!=null));i++){
            if(list1.val<list2.val){
                head.next = list1;
                if(i==0)
                    first = head;
                head = head.next;
                list1 = list1.next;
            }
            else{
                head.next = list2;
                if(i==0)
                    first = head;
                head = head.next;
                list2 = list2.next;
            }
        }
        if(list1==null)
            head.next = list2;
        if(list2==null)
            head.next = list1;
        return first.next;
    }
}
```

剑指Offer的解答：

当我们得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1==null)
            return list2;
        if(list2==null)
            return list1;
        if(list1.val<list2.val){
            list1.next = Merge(list1.next, list2);
            return list1;
        }
        else{
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }
}
```

# 面试题26_树的子结构

题目：输入两棵二叉树A，B，判断B是不是A的子结构。(ps：我们约定空树不是任意一个树的子结构)

解析：

1.一个比较容易想到的思路(我的思路)就是设定一个函数，subTree(TreeNode root1, TreeNode root2)用于判断以root1为起始根节点的二叉树是否包含root2的子结构，再将HasSubtree中的root1进行遍历，每一个节点都调用subTree()函数

2.该题考查编写代码的鲁棒性，完整性，标准答案与博主思路类同

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.LinkedList;
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null)
            return false;
        if(root1==null)
            return false;
        LinkedList<TreeNode> queue1 = new LinkedList<TreeNode>();
        queue1.push(root1);
        while(!queue1.isEmpty()){
            TreeNode first = queue1.pop();
            if(subTree(first, root2))
                return true;
            if(first.left!=null)
                queue1.push(first.left);
            if(first.right!=null)
                queue1.push(first.right);
        }
        return false;
    }
    public boolean subTree(TreeNode root1, TreeNode root2){
        LinkedList<TreeNode> queue1 = new LinkedList<TreeNode>();
        LinkedList<TreeNode> queue2 = new LinkedList<TreeNode>();
        queue1.push(root1);
        queue2.push(root2);
        while(!queue2.isEmpty()){
            TreeNode first1 = queue1.pop();
            TreeNode first2 = queue2.pop();
            if(first1.val!=first2.val)
                return false;
            if(first2.left!=null){
                if(first1.left==null)
                    return false;
                queue2.push(first2.left);
                queue1.push(first1.left);
            }
            if(first2.right!=null){
                if(first1.right==null)
                    return false;
                queue2.push(first2.right);
                queue1.push(first1.right);
            }
        }
        return true;
    }
}
```

# 面试题27_二叉树的镜像

题目：操作给定的二叉树，将其变换为源二叉树的镜像

解析：

1.博主思路：借助队列的数据结构遍历二叉树，将每个节点的左右子树对换即可

2.本题考查面试者对于二叉树的理解，本质上在考查二叉树的遍历算法

3.博主的思路为借助队列进行层序遍历，那么如果使用其它的二叉树遍历方式，该如何编写？

借助队列进行按层遍历的解决方式：

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.LinkedList;
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        queue.push(root);
        while(!queue.isEmpty()){
            TreeNode first  = queue.pop();
            TreeNode temp = first.left;
            first.left = first.right;
            first.right = temp;
            if(first.left!=null)
                queue.push(first.left);
            if(first.right!=null)
                queue.push(first.right);
        }
    }
}
```

借助递归的解决方式

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return ;
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        if(root.left!=null)
            Mirror(root.left);
        if(root.right!=null)
            Mirror(root.right);
    }
}
```

# 面试题29_顺时针打印矩阵

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

总结：

1.有些情况下头尾索引都包含的话有利于编写代码，比如上述的这道题，如果只包含头索引而不包含尾索引的话，可能会麻烦一点，当然这一点并不是必须遵守的

2.四个for循环中循环条件很重要，很容易把&&后的条件漏掉而导致错误

3.该题考查面试者逻辑思维能力，若考虑的不周全，代码很容易在某些输入下出现错误

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        int rmin=0;
        int rmax=matrix.length-1;
        int cmin=0;
        int cmax=matrix[0].length-1;
        while(rmin<=rmax && cmin<=cmax){
           for(int j=cmin;j<=cmax && rmin<=rmax;j++)
               list.add(matrix[rmin][j]);
           rmin++;
           for(int i=rmin;i<=rmax && cmin<=cmax;i++)
               list.add(matrix[i][cmax]);
           cmax--;
           for(int j=cmax;j>=cmin && rmin<=rmax;j--)
               list.add(matrix[rmax][j]);
           rmax--;
            for(int i=rmax;i>=rmin && cmin<=cmax;i--)
                list.add(matrix[i][cmin]);
           cmin++;
        }
        return list;
    }
}
```

# 面试题30_包含min函数的栈

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

解析：

1.pretty easy

```java
import java.util.Stack;
public class Solution {
    Stack<Integer> s = new Stack<Integer>();
    Stack<Integer> smin = new Stack<Integer>();
    public void push(int node) {
        s.push(node);
        if(smin.isEmpty()){
            smin.push(node);
        }
        else{
            if(node<smin.peek())
                smin.push(node);
            else
                smin.push(smin.peek());
        }
    }
    public void pop() {
        s.pop();
        smin.pop();
    }
    
    public int top() {
        smin.pop();
        return s.pop();
    }
    public int min() {
        return smin.peek();
    }
}
```

# 面试题31_栈的压入_弹出序列

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。注意：这两个序列的长度是相等的

解析：

1.构造一个辅助栈来模拟栈的压入弹出即可，为了方便查找popA中的某个数字在不在pushA中(除去已经压入栈中的数字的pushA)，这里将pushA中的数字也存储在了ArrayList结构中

2.要注意当stackA中和stackTemp中都没有popA中的某一个数字，则返回false

3.该题考查应聘者分析复杂问题的能力，可以通过举一两个例子，一步步分析压栈和弹出的过程，总中找出规律

```java
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA==null && popA==null)
            return true;
        if(pushA==null || popA==null)
            return false;
        ArrayList<Integer> stackA = new ArrayList<Integer>();
        ArrayList<Integer> stackTemp = new ArrayList<Integer>();
        for(int i=0;i<pushA.length;i++)
            stackA.add(pushA[i]);
        for(int i=0;i<popA.length;i++){
            int index = stackA.indexOf(popA[i]);
            int indexTemp = stackTemp.indexOf(popA[i]);
            if(index!=-1){
                for(int j=0;j<=index;j++)
                    stackTemp.add(stackA.remove(0));
                stackTemp.remove(stackTemp.size()-1);
            }
            else if(index==-1 && indexTemp!=-1){
                if(stackTemp.remove(stackTemp.size()-1)!=popA[i])
                    return false;
            }
            else
                return false;
        }
        return true;
    }
}
```

# 面试题32_从上到下打印二叉树

题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印

总结：

1.当root为空的时候，不应该返回null，那样的话会报错，因为方法的返回值类型为ArrayList<Integer>所以如果返回为null的话就相当于

```java
ArrayList<Integer> list = null;//java.lang.NullPointerException
```

应该返回为new ArrayList<Integer>();相当于(为什么上边有的程序返回为null就可以？)

```java
ArrayList<Integer> list = new ArrayList<Integer>();
```

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        if(root==null)
            return new ArrayList<Integer>();//注意返回不应该为null
        ArrayList<TreeNode> listNode = new ArrayList<TreeNode>();
        ArrayList<Integer> listInteger = new ArrayList<Integer>();
        listNode.add(root);
        while(!listNode.isEmpty()){
            TreeNode first = listNode.remove(0);
            listInteger.add(first.val);
            if(first.left!=null)
                listNode.add(first.left);
            if(first.right!=null)
                listNode.add(first.right);
        }
        return listInteger;
    }
}
```


# 面试题56_数组中数字出现的次数

题目一：数组中只出现一次的两个数字

一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现过一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)

提示：

1.如果只有一个数字只出现了一次，其他数字均出现了两次，该如何编写程序

2.所有数字异或的结果肯定不会是0，可以根据右边数第一个不为1的位置将数组分为两组

```java
    //数组num1和num2用于接收只出现过一次的两个数字
    static void findNumsApperOnce(int[] arr, int[] num1, int[] num2){
        if(arr.length < 2)
            return;
        num1[0] = arr[0];
        num2[0] = arr[1];
        int temp = arr[0];
        for(int i = 0;i<arr.length;i++){
            temp = temp^arr[i];
        }
        int pos;
        for(pos = 0;(temp&1)!=1;pos++)
            temp = temp>>1;
        for(int i=0;i<arr.length;i++){
            if((arr[i]>>pos)==0)
                num1[0]^=arr[i];
            else
                num2[0]^=arr[i];
        }
    }
```

题目二：数组中唯一只出现一次的数字

在一个数组中出=除一个数字只出现一次外，其他数字都出现了三次，请找出那个只出现一次的数字

解析：

1.使用位运算。将所有数字的二进制表示按位相加，如果某位是3的倍数，则表示只出现一次的那个数字在该位上为0，否则为1

2.常规解法：

    1.将数组排序，从排序了的数组找是很容易的，排序算法的话需要O(nlogn)时间

    2.用一个哈希表来记录每个数字出现的次数，但是哈希表需要O(n)的空间  

3.我们下面实现的算法的时间效率为O(n)，我们需要一个长度为32的辅助数组，因为辅助数组的长度是固定的，所以空间复杂度为O(1)

```java
    static int findNumberApperingOnce(int[] arr){
            int[] bit = new int[32];
            for(int i=0;i<arr.length;i++){
                int temp = 1;
                for(int j=0;j<32;j++){
                    bit[j]+=(arr[i]&(temp<<j))>>>j;
                }
            }
            int res = 0;
            for(int i=0;i<32;i++){
                if(bit[i]%3==1)
                    res+=(1<<i);
            }
            return res;
        }
```
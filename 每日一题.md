牛客网版目录
* [注意事项](#注意事项)
* [二维数组中的查找](#面试题04_二维数组中的查找)
* [替换空格](#面试题05_替换空格)


剑指Offer版目录
* [注意事项](#注意事项)
* [面试题04_二维数组中的查找](#面试题04_二维数组中的查找)
* [面试题05_替换空格](#面试题05_替换空格)
* [面试题16_数值的整数次方](#面试题16_数值的整数次方)
* [面试题15_二进制中1的个数](#面试题15_二进制中1的个数)
* [面试题56_数组中数字出现的次数](#面试题56_数组中数字出现的次数)

# 注意事项

1.如无特别说明，方法均写在了Sword类中，测试代码均写在了Test类中，有很多方法直接在牛客网上书写并没有对应的测试代码

# 面试题04_二维数组中的查找
题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

```java
    public boolean Find(int target, int [][] array) {
        int r = array.length-1;
        int c = 0;
        while(r>-1 && c<array[0].length){
            if(target==array[r][c])
                return true;
            else if(target>array[r][c])
                c++;
            else
                r--;
        }
        return false;
    }
```

# 面试题05_替换空格

题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy

解析：

1.我们肯定要用到空格判断，那么怎么从字符串里边读取每个字符呢？查找API以下是我们可能会用到的方法

    StringBuffer(int capacity)
          构造一个不带字符，但具有指定初始容量的字符串缓冲区
    char charAt(int index)
          返回此序列中指定索引处的 char 值
    int length()
          返回长度（字符数）
    void setCharAt(int index, char ch)
          将给定索引处的字符设置为 ch
    void setLength(int newLength)
          设置字符序列的长度
    String toString()
          返回此序列中数据的字符串表示形式

其中的setLength方法：

```java
setLength
public void setLength(int newLength)设置字符序列的长度。序列将被更改为一个新的字符序列，新序列的长度由参数指定。对于每个小于 newLength 参数的非负索引 k，如果 k 小于原字符序列的长度，则新字符序列索引 k 处的字符与原字符序列索引 k 处的字符相同；否则，新字符序列索引 k 处的字符将是 null 字符 '\u0000'。换句话说，如果 newLength 参数小于当前长度，则长度将更改为指定的长度。 
如果 newLength 参数大于或等于当前长度，则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数。 

newLength 参数必须大于或等于 0。 


参数：
newLength - 新长度 
抛出： 
IndexOutOfBoundsException - 如果 newLength 参数为负。
另请参见：
length()
```

2.还需明确一点就是容量和长度是两个不同的概念

```java
length
public int length()返回长度（字符数）。 

指定者：
接口 CharSequence 中的 length
返回：
此对象表示的当前字符序列的长度。

--------------------------------------------------------------------------------

capacity
public int capacity()返回当前容量。容量指可用于最新插入的字符的存储量，超过这一容量就需要再次进行分配。 

返回：
当前容量。
```

所以有

```java
        StringBuffer str = new StringBuffer(13);
        System.out.println(str.length());
        System.out.println(str.capacity());

/*
$ java Test
0
13
*/
```

明确了这个知识点之后就知道如下程序是错误的了

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        StringBuffer newStr = new StringBuffer(newStrLength);
        int index = newStr.length()-1;//这里的newStr.length()为0而不是newStrLength
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                newStr.setCharAt(index--,'0');
                newStr.setCharAt(index--,'2');
                newStr.setCharAt(index--,'%');
            }
            else
                newStr.setCharAt(index--,str.charAt(i));
        }
        return newStr.toString();
    }
```


3.思路：我们可以先遍历一遍数组，查看有多少空格，再将字符序列长度设置为替换空格之后的长度，从后向前求解新的字符串

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        str.setLength(newStrLength);
        int index = newStrLength-1;
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                str.setCharAt(index--,'0');
                str.setCharAt(index--,'2');
                str.setCharAt(index--,'%');
            }
            else
                str.setCharAt(index--,str.charAt(i));
        }
        return str.toString();
    }
```

# 面试题16_数值的整数次方

题目：实现函数double Power(double base, int exponent)，求base得exponent次方。不得使用库函数，同时不需要考虑大数问题

解析：

1.base为0的时候，exponent不可以同时为0，这个时候程序的规定输出要和面试官说明(本程序此种情况输出为0)，表明我们考虑到了这种情况，其实博主觉得可以考虑在此种情况下输出异常

2.当base为0的时候，exponent不为0则输出为0

3.注意exponent的取值，取正值，取负值，取负值的结果等于其绝对值的power取倒数，取0，结果为1

4.考虑高效算法

![power](https://github.com/geekavan/Sword/blob/master/power.png)

5.可以通过位运算判断一个数的奇偶，(exponent & 1)==0

综上，我们有：

```java
public class Sword{
    static double power(double base, int exponent){
        if(base==0 && exponent==0)
            return 0;
        if(base==0)
            return 0;
        if(exponent<0)
            return 1/(power(base, -exponent));
        if(exponent==0)
            return 1;
        if(exponent%2==0){
            double temp = power(base, exponent/2);
            return temp*temp;
        }
        else
            return base*power(base, (exponent-1));
    }
}
class Test{
    public static void main(String[] args){
        double s16  = Sword.power(5, -2);
        System.out.println(s16);
    }
}
/*
$ java Test
0.04
*/
```

# 面试题15_二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数

解析：

1.把一个整数减去1，之后再和原来那个整数做位与运算，这个操作相当于把这个整数的二进制表示的最右边的1置为0，很多问题都可以用这个trick来解决

```java
    static int numberOf1(int number){
        int result = 0;
        while((number&(number-1))!=0){
            result++;
            number = number&(number-1);
        }
        return result;
    }
```

# 面试题56_数组中数字出现的次数

题目一：数组中只出现一次的两个数字

一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现过一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)

提示：

1.如果只有一个数字只出现了一次，其他数字均出现了两次，该如何编写程序

2.所有数字异或的结果肯定不会是0，可以根据右边数第一个不为1的位置将数组分为两组

```java
    //数组num1和num2用于接收只出现过一次的两个数字
    static void findNumsApperOnce(int[] arr, int[] num1, int[] num2){
        if(arr.length < 2)
            return;
        num1[0] = arr[0];
        num2[0] = arr[1];
        int temp = arr[0];
        for(int i = 0;i<arr.length;i++){
            temp = temp^arr[i];
        }
        int pos;
        for(pos = 0;(temp&1)!=1;pos++)
            temp = temp>>1;
        for(int i=0;i<arr.length;i++){
            if((arr[i]>>pos)==0)
                num1[0]^=arr[i];
            else
                num2[0]^=arr[i];
        }
    }
```

题目二：数组中唯一只出现一次的数字

在一个数组中出=除一个数字只出现一次外，其他数字都出现了三次，请找出那个只出现一次的数字

解析：

1.使用位运算。将所有数字的二进制表示按位相加，如果某位是3的倍数，则表示只出现一次的那个数字在该位上为0，否则为1

2.常规解法：

    1.将数组排序，从排序了的数组找是很容易的，排序算法的话需要O(nlogn)时间

    2.用一个哈希表来记录每个数字出现的次数，但是哈希表需要O(n)的空间  

3.我们下面实现的算法的时间效率为O(n)，我们需要一个长度为32的辅助数组，因为辅助数组的长度是固定的，所以空间复杂度为O(1)

```java
    static int findNumberApperingOnce(int[] arr){
            int[] bit = new int[32];
            for(int i=0;i<arr.length;i++){
                int temp = 1;
                for(int j=0;j<32;j++){
                    bit[j]+=(arr[i]&(temp<<j))>>>j;
                }
            }
            int res = 0;
            for(int i=0;i<32;i++){
                if(bit[i]%3==1)
                    res+=(1<<i);
            }
            return res;
        }
```
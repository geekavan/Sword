牛客网版目录
* [注意事项](#注意事项)
* [二维数组中的查找](#面试题04_二维数组中的查找)
* [替换空格](#面试题05_替换空格)
* [从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [重建二叉树](#面试题07_重建二叉树)
* [用两个栈实现队列](#面试题09_用两个栈实现队列)
* [甜点](#第一星期甜点)
    * [length属性与length()函数](#length属性与length函数)
* [旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [斐波那契数列](#面试题10_斐波那契数列)
    * [青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [变态跳台阶](#本题扩展变态跳台阶)
    * [矩形覆盖](#相关题目矩形覆盖)

剑指Offer版目录
* [注意事项](#注意事项)
* [面试题04_二维数组中的查找](#面试题04_二维数组中的查找)
* [面试题05_替换空格](#面试题05_替换空格)
* [面试题06_从尾到头打印链表](#面试题06_从尾到头打印链表)
    * [自己的方法](#自己的方法)
    * [答案1](#答案1_利用栈)
    * [答案2](#答案2_利用递归)
* [面试题07_重建二叉树](#面试题07_重建二叉树)
* [面试题09_用两个栈实现队列](#面试题09_用两个栈实现队列)
* [面试题10_斐波那契数列](#面试题10_斐波那契数列)
    * [题目二青蛙跳台阶问题](#题目二青蛙跳台阶问题)
    * [本题扩展变态跳台阶](#本题扩展变态跳台阶)
    * [相关题目矩形覆盖](#相关题目矩形覆盖)
* [面试题11_旋转数组的最小数字](#面试题11_旋转数组的最小数字)
* [面试题16_数值的整数次方](#面试题16_数值的整数次方)
* [面试题15_二进制中1的个数](#面试题15_二进制中1的个数)
* [面试题56_数组中数字出现的次数](#面试题56_数组中数字出现的次数)

# 注意事项

1.如无特别说明，方法均写在了Sword类中，测试代码均写在了Test类中，有很多方法直接在牛客网上书写并没有对应的测试代码

2.每道题的总结或解析部分给出了这道题应该注意的点，或者说这道题考察的点

# 面试题04_二维数组中的查找
题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

```java
    public boolean find(int target, int [][] array) {
        int r = array.length-1;
        int c = 0;
        while(r>-1 && c<array[0].length){
            if(target==array[r][c])
                return true;
            else if(target>array[r][c])
                c++;
            else
                r--;
        }
        return false;
    }
```

# 面试题05_替换空格

题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy

解析：

1.我们肯定要用到空格判断，那么怎么从字符串里边读取每个字符呢？查找API以下是我们可能会用到的方法

    StringBuffer(int capacity)
          构造一个不带字符，但具有指定初始容量的字符串缓冲区
    char charAt(int index)
          返回此序列中指定索引处的 char 值
    int length()
          返回长度（字符数）
    void setCharAt(int index, char ch)
          将给定索引处的字符设置为 ch
    void setLength(int newLength)
          设置字符序列的长度
    String toString()
          返回此序列中数据的字符串表示形式

其中的setLength方法：

```java
setLength
public void setLength(int newLength)设置字符序列的长度。序列将被更改为一个新的字符序列，新序列的长度由参数指定。对于每个小于 newLength 参数的非负索引 k，如果 k 小于原字符序列的长度，则新字符序列索引 k 处的字符与原字符序列索引 k 处的字符相同；否则，新字符序列索引 k 处的字符将是 null 字符 '\u0000'。换句话说，如果 newLength 参数小于当前长度，则长度将更改为指定的长度。
如果 newLength 参数大于或等于当前长度，则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数。

newLength 参数必须大于或等于 0。


参数：
newLength - 新长度
抛出：
IndexOutOfBoundsException - 如果 newLength 参数为负。
另请参见：
length()
```

2.还需明确一点就是容量和长度是两个不同的概念

```java
length
public int length()返回长度（字符数）。

指定者：
接口 CharSequence 中的 length
返回：
此对象表示的当前字符序列的长度。

--------------------------------------------------------------------------------

capacity
public int capacity()返回当前容量。容量指可用于最新插入的字符的存储量，超过这一容量就需要再次进行分配。 

返回：
当前容量。
```

所以有

```java
        StringBuffer str = new StringBuffer(13);
        System.out.println(str.length());
        System.out.println(str.capacity());

/*
$ java Test
0
13
*/
```

明确了这个知识点之后就知道如下程序是错误的了

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        StringBuffer newStr = new StringBuffer(newStrLength);
        int index = newStr.length()-1;//这里的newStr.length()为0而不是newStrLength
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                newStr.setCharAt(index--,'0');
                newStr.setCharAt(index--,'2');
                newStr.setCharAt(index--,'%');
            }
            else
                newStr.setCharAt(index--,str.charAt(i));
        }
        return newStr.toString();
    }
```


3.思路：我们可以先遍历一遍数组，查看有多少空格，再将字符序列长度设置为替换空格之后的长度，从后向前求解新的字符串

```java
public static String replaceSpace(StringBuffer str) {
        int spaceNumbers = 0;
        int strLength = str.length();
        for(int i=0; i<strLength; i++){
            if(str.charAt(i)==' ')
                spaceNumbers++;
        }
        int newStrLength = strLength+spaceNumbers*2;
        str.setLength(newStrLength);
        int index = newStrLength-1;
        for(int i=strLength-1;i>-1;i--){
            if(str.charAt(i)==' '){
                str.setCharAt(index--,'0');
                str.setCharAt(index--,'2');
                str.setCharAt(index--,'%');
            }
            else
                str.setCharAt(index--,str.charAt(i));
        }
        return str.toString();
    }
```

# 面试题06_从尾到头打印链表

题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList

### 自己的方法

自己的思路：

1.先遍历一遍链表，查看链表中元素的个数listNodeLength

2.再新建一个ArrayList对象，使其长度为listNodeLength

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面

问题：

可以新建一个ArrayList对象，使其容量为listNodeLength但是却不能使其元素数为listNodeLength，如下：

```java
ArrayList<Integer> al = new ArrayList<Integer>(13);
al.add(1,12);
/*
$ java Test
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 1, Size: 0
        at java.util.ArrayList.rangeCheckForAdd(Unknown Source)
        at java.util.ArrayList.add(Unknown Source)
        at Test.main(Test.java:16)
*/
```

如上虽然容量为13，但是Size依然为0，并没有1的索引，所以改进思路为：

1.新建立一个ArrayList对象

2.遍历一遍链表，将链表上的值依次存储在ArrayList对象里边

3.第二次遍历链表，把先遍历到的数值储存到ArrayList对象的后面(改变原ArrayList的值)

```java
public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        ListNode head = listNode;
        while(listNode!=null){
            al.add(listNode.val);
            listNode = listNode.next;
        }
        for(int i=al.size()-1;i>-1;i--){
            al.set(i, head.val);
            head = head.next;
        }
        return al;
    }
```

### 答案1_利用栈

解析：

1.从头到尾遍历一遍链表，先遍历到的后输出，后遍历到的先输出，这是明显的先进后出规则，我们可以使用栈结构来实现

相关API

    boolean empty()
          测试堆栈是否为空
    E pop()
          移除堆栈顶部的对象，并作为此函数的值返回该对象
    E push(E item)
          把项压入堆栈顶部

```java
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode==null)
            return new ArrayList<Integer>();
        Stack<Integer> s = new Stack<Integer>();
        ArrayList<Integer> al = new ArrayList<Integer>();
        while(listNode!=null){
            s.push(listNode.val);
            listNode = listNode.next;
        }
        while(!s.empty()){
            al.add(s.pop());
        }
        return al;
    }
```

### 答案2_利用递归

我们始终要记住一点：递归的本质就是一种栈结构，所以上述方式完全可以用递归方法改写

```java
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode!=null){
            //每次压栈时，里边都存有下一次压栈后printListFromTailToHead返回的ArrayList的引用变量al，在al里边add这一次压栈的节点的val值，返回al
            ArrayList<Integer> al = printListFromTailToHead(listNode.next);
            al.add(listNode.val);
            return al;
        }
        return new ArrayList();
    }
}
```

# 面试题07_重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

```java
public static TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0)
            return null;
        TreeNode root = new TreeNode(pre[0]);
        int rootIndex = 0;
        while(pre[0]!=in[rootIndex]){
            rootIndex++;
        }
        int[] leftIn = Arrays.copyOfRange(in, 0, rootIndex);
        int[] rightIn = Arrays.copyOfRange(in, rootIndex+1, in.length);
        int[] leftPre = Arrays.copyOfRange(pre, 1, rootIndex+1);
        int[] rightPre = Arrays.copyOfRange(pre, rootIndex+1, pre.length);
        root.left = reConstructBinaryTree(leftPre , leftIn);
        root.right = reConstructBinaryTree(rightPre ,rightIn);
        return root;
    }
```

# 面试题09_用两个栈实现队列

```java
import java.util.Stack;

class Queue{
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public void push(int node) {
         while(!stack2.empty()){
            stack1.push(stack2.pop());
        }
        stack1.push(node);

    }
    public int pop() {
        while(!stack1.empty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```

# 第一星期甜点

# length属性与length函数

1.length为属性，求得数组长度；length()为函数，用于求字符串的长度；size()函数用于求泛型类的元素多少

2.为什么数组的长度为属性，而字符串的长度(或者说泛型类的元素个数)为函数？

这是因为数组的长度一旦确定并不可以改动，而字符串长度(或者说泛型类的元素个数)可以改动，示例如下：

```java
import java.util.ArrayList;
class LengthTest{
    public static void main(String[] args){
        int[] arr = new int[8];
        int arrLength = arr.length;
        System.out.println("arrLength: "+arrLength);

        String s = new String();
        s = " hello world ";
        System.out.println("sLength: "+s.length());
        s = s.trim();
        System.out.println("sLength: "+s.length());

        ArrayList<Integer> arrList = new ArrayList<Integer>();
        System.out.println("arrListLength: "+arrList.size());
        arrList.add(5);
        System.out.println("arrListLength: "+arrList.size());
    }
}
/*
$ java LengthTest
arrLength: 8
sLength: 13
sLength: 11
arrListLength: 0
arrListLength: 1
*/
```

# 面试题11_旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

NOTE：给出的所有元素都大于0，若数组大小为0，请返回0

总结：

1.O(n)的方法很容易想到，但是并不是最优的

2.要注意并利用到旋转数组被分为了两个排序数组的特征

3.要考虑到{1,0,1,1,1,1}这类若干元素相等的情况

4.要考虑到{0,1,2,3,4,5,6}这类，把一个数组最开始的**0**个元素搬到数组的末尾的特殊情况

很容易想到当出现一个数大于后面的数字，那么后面的那个数字就是最小的数，程序如下，但是这种方法的时间复杂度为O(n)

1.该方法没有用到太多的旋转数组的特性，只认识到了"当出现一个数大于后面的数字，那么后面的那个数字就是最小的数"，其实还应该认识到，**旋转数组旋转之后变为了两个排序数组**

```java
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        else{
            for(int i=0;i<array.length-1;){
                if(array[i]>array[++i])
                    return array[i];
            }
        }
        return -1;//当输入为非法数组(非符合要求的旋转数组)的时候的输出，这点可以和面试官确认一下，表示我们考虑到了这种情况
    }
```

又想到能否使用递归呢？

```java
    public int minNumberInRotateArray(int [] array) {
        int index = array.length/2;
        if(index==0)
            return -1;
        if(array[index-1]>array[index])
            return array[index];
        int left = minNumberInRotateArray(Arrays.copyOfRange(array, 0, index));
        int right = minNumberInRotateArray(Arrays.copyOfRange(array, index, array.length));
        if(left!=-1)
            return left;
        if(right!=-1)
            return right;
        return -1;
    }
```

牛客网中一java版高赞回答，是错误的，没有考虑到特殊情况，如{1,0,1,1,1,1}，但是该方法注意到了旋转数组为两个排序数组的特性(注意还有不旋转的排序数组也是旋转数组)，也没有考虑到{0,1,2,3,4,5,6,7,8,9}的情况

```java
public class Test11{
    public static void main(String[] args){
        int[] arr = {1,0,1,1,1,1,1};
        int min = minNumberInRotateArray(arr);
        System.out.println(min);
    }
    public static int minNumberInRotateArray(int[] array) {
        if (array.length == 0)
            return 0;
        int left = 0;
        int right = array.length - 1;
        int middle = -1;
        while (array[left]>=array[right]) {
            if(right-left==1){
                middle = right;
                break;
            }
            middle = left + (right - left) / 2;
            if (array[middle] >= array[left]) {
                left = middle;
            }
            if (array[middle] <= array[right]) {
                right = middle;
            }
        }
        return array[middle];
    }
}
```

上述程序会陷入死循环，将其修改后为：

```java
public class Test11_1{
    public static void main(String[] args){
        int[] arr0 = {1,0,1,1,1,1,1};
        int[] arr1 = {5,6,7,8,0,1,2,3,4};
        int[] arr2 = {0,1,2,3,4,5,6,7,8};
        int min = minNumberInRotateArray(arr1);
        System.out.println(min);
        System.exit(0);
    }
    public static int minNumberInRotateArray(int[] array) {
        if(array==null)
            throw new RuntimeException("数组不可以为空");
        int leftIndex = 0;
        int rightIndex = array.length-1;
        if(array[leftIndex]<array[rightIndex]){
            return array[leftIndex];
        }
        int midIndex;
        while((rightIndex-leftIndex)>1){
            midIndex = (leftIndex + rightIndex)/2;
            int temp;
            if(array[leftIndex] > array[midIndex])
                rightIndex = midIndex;
            else if(array[leftIndex] < array[midIndex])
                leftIndex = midIndex;
            else if((array[leftIndex] == array[midIndex]) || (array[rightIndex] == array[midIndex])){
                temp = leftIndex+1;
                if(array[leftIndex] == array[temp])
                    leftIndex++;
                temp = rightIndex-1;
                if(array[rightIndex] == array[temp])
                    rightIndex--;
            }
        }
        return array[rightIndex];
    }
}
```

# 面试题10_斐波那契数列

题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

总结：

1.递归方式很容易想到，但是会计算重复项，效率不高

2.从第一项计算到第n项可取

3.有更高阶的方式解决此题，比如通项公式等

递归的方式很容易想到

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}
```

但是递归的问题是，一个斐波那契数列项会被多次重复计算，比如计算f(10)=f(9)+f(8)，而计算f(9)的时候又会计算f(8)，导致计算的速度很慢，可以重第一项计算到第n项，就不会出现重复计算的情况

```java
    public static int Fibonacci(int n) {
        if(n<0){
            throw new RuntimeException("n必须大于等于0");
        }
        int first = 0;
        int second = 1;
        int temp;
        for(int i=0;i<n;i++){
            first = first+second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
```
### 题目二青蛙跳台阶问题

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target<=0)
            throw new RuntimeException("target必须大于0");
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```

### 本题扩展变态跳台阶

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

解析：用归纳法不难证明答案为2的n次方，但是此题的知识点归类为贪婪算法，查看讨论中，并未发现应用贪婪算法的解法

```java
public class Solution {
    public int JumpFloorII(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于等于1");
        return 1<<(target-1);
    }
}
```

### 相关题目矩形覆盖

题目：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？

解析：和斐波那契数列是同一个类型的问题

```java
public class Solution {
    public int RectCover(int target) {
        if(target<0)
            throw new RuntimeException("参数必须大于0");
        if(target==0)
            return 0;
        int first = 1;
        int second = 2;
        int temp;
        for(int i=1;i<target;i++){
            first = first + second;
            temp = first;
            first = second;
            second = temp;
        }
        return first;
    }
}
```


# 面试题16_数值的整数次方

题目：实现函数double Power(double base, int exponent)，求base得exponent次方。不得使用库函数，同时不需要考虑大数问题

解析：

1.base为0的时候，exponent不可以同时为0，这个时候程序的规定输出要和面试官说明(本程序此种情况输出为0)，表明我们考虑到了这种情况，其实博主觉得可以考虑在此种情况下输出异常

2.当base为0的时候，exponent不为0则输出为0

3.注意exponent的取值，取正值，取负值，取负值的结果等于其绝对值的power取倒数，取0，结果为1

4.考虑高效算法

![power](https://github.com/geekavan/Sword/blob/master/power.png)

5.可以通过位运算判断一个数的奇偶，(exponent & 1)==0

综上，我们有：

```java
public class Sword{
    static double power(double base, int exponent){
        if(base==0 && exponent==0)
            return 0;
        if(base==0)
            return 0;
        if(exponent<0)
            return 1/(power(base, -exponent));
        if(exponent==0)
            return 1;
        if(exponent%2==0){
            double temp = power(base, exponent/2);
            return temp*temp;
        }
        else
            return base*power(base, (exponent-1));
    }
}
class Test{
    public static void main(String[] args){
        double s16  = Sword.power(5, -2);
        System.out.println(s16);
    }
}
/*
$ java Test
0.04
*/
```

# 面试题15_二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数

解析：

1.把一个整数减去1，之后再和原来那个整数做位与运算，这个操作相当于把这个整数的二进制表示的最右边的1置为0，很多问题都可以用这个trick来解决

```java
    static int numberOf1(int number){
        int result = 0;
        while((number&(number-1))!=0){
            result++;
            number = number&(number-1);
        }
        return result;
    }
```

# 面试题56_数组中数字出现的次数

题目一：数组中只出现一次的两个数字

一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现过一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)

提示：

1.如果只有一个数字只出现了一次，其他数字均出现了两次，该如何编写程序

2.所有数字异或的结果肯定不会是0，可以根据右边数第一个不为1的位置将数组分为两组

```java
    //数组num1和num2用于接收只出现过一次的两个数字
    static void findNumsApperOnce(int[] arr, int[] num1, int[] num2){
        if(arr.length < 2)
            return;
        num1[0] = arr[0];
        num2[0] = arr[1];
        int temp = arr[0];
        for(int i = 0;i<arr.length;i++){
            temp = temp^arr[i];
        }
        int pos;
        for(pos = 0;(temp&1)!=1;pos++)
            temp = temp>>1;
        for(int i=0;i<arr.length;i++){
            if((arr[i]>>pos)==0)
                num1[0]^=arr[i];
            else
                num2[0]^=arr[i];
        }
    }
```

题目二：数组中唯一只出现一次的数字

在一个数组中出=除一个数字只出现一次外，其他数字都出现了三次，请找出那个只出现一次的数字

解析：

1.使用位运算。将所有数字的二进制表示按位相加，如果某位是3的倍数，则表示只出现一次的那个数字在该位上为0，否则为1

2.常规解法：

    1.将数组排序，从排序了的数组找是很容易的，排序算法的话需要O(nlogn)时间

    2.用一个哈希表来记录每个数字出现的次数，但是哈希表需要O(n)的空间  

3.我们下面实现的算法的时间效率为O(n)，我们需要一个长度为32的辅助数组，因为辅助数组的长度是固定的，所以空间复杂度为O(1)

```java
    static int findNumberApperingOnce(int[] arr){
            int[] bit = new int[32];
            for(int i=0;i<arr.length;i++){
                int temp = 1;
                for(int j=0;j<32;j++){
                    bit[j]+=(arr[i]&(temp<<j))>>>j;
                }
            }
            int res = 0;
            for(int i=0;i<32;i++){
                if(bit[i]%3==1)
                    res+=(1<<i);
            }
            return res;
        }
```